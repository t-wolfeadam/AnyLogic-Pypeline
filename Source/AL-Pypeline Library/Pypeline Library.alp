<?xml version="1.0" encoding="UTF-8"?>
<!--
*************************************************
	         AnyLogic Project File 
*************************************************	         
-->
<AnyLogicWorkspace WorkspaceVersion="1.9" AnyLogicVersion="8.8.4.202307181709" AlpVersion="8.8.2">
<Model>
	<Id>1567802082268</Id>
	<Name><![CDATA[Pypeline Library]]></Name>
	<Description><![CDATA[The library for being able to run Python within an AnyLogic model]]></Description>
	<EngineVersion>6</EngineVersion>
	<JavaPackageName><![CDATA[com.anylogic.libraries.pypeline]]></JavaPackageName>
	<ModelTimeUnit><![CDATA[Second]]></ModelTimeUnit>
	<OptionLists>
		<OptionList>
			<Id>1574961034301</Id>
			<Name><![CDATA[PythonCommandType]]></Name>
			<Description><![CDATA[Option list for choosing the method to connecting to Python.<br>
<code>PYTHON</code>, <code>PYTHON2</code>, and <code>PYTHON3</code> all represent the command used to call Python from a termianl (using the commands <code>python</code>, <code>python2</code>, and <code>python3</code>, respectively).<br>
<code>PYTHON_OTHER</code> is used to indicate an 'other' command alias.<br>
<code>PYTHON_PATH</code> is used to indicate that an absolute path will be given to the desired Python executable.]]></Description>
			<Option>
				<Id>1574961050485</Id>
				<Name><![CDATA[PYTHON]]></Name>
			</Option>
			<Option>
				<Id>1574961045397</Id>
				<Name><![CDATA[PYTHON2]]></Name>
			</Option>
			<Option>
				<Id>1574961047949</Id>
				<Name><![CDATA[PYTHON3]]></Name>
			</Option>
			<Option>
				<Id>1574961034631</Id>
				<Name><![CDATA[PYTHON_OTHER]]></Name>
			</Option>
			<Option>
				<Id>1589489938747</Id>
				<Name><![CDATA[PYTHON_PATH]]></Name>
			</Option>
		</OptionList>
	</OptionLists>
	<ActiveObjectClasses>
		<!--   =========   Active Object Class   ========  -->
		<ActiveObjectClass>
			<Id>1569858524855</Id>
			<Name><![CDATA[PyCommunicator]]></Name>
			<Description><![CDATA[<h4>Python Communicator</h4>
<h5>Dragging this agent into a model allows you to run Python code as part of your model.</h5>

Available functions, with name and description:<br>
(See code completion for more info)<br>
<table border="1">
  <tr>
    <td><code>isConnected</code></td>
    <td style="font-size:12">Pings the server to check if it's still alive</td>
  </tr>
  <tr>
    <td><code>run</code></td>
    <td style="font-size:12">Execute a statement (return void)</td>
  </tr>
  <tr>
    <td><code>runResults</code></td>
    <td style="font-size:12">Evaluation an expression (return some results)</td>
  </tr>
  <tr>
	<td><code>runFile</code></td>
	<td style="font-size:12">Runs a file and returns the output. Can be used as part of an active object or staticly.</td>
  </tr>
</table>
Note 1: all calls return an <code>Attempt</code> object. <br>
You can query the success and feedback using the <code>isSuccessful</code> and <code>getFeedback</code> functions.<br>
<br>
In addition to single-line Python code, you can also pass multiline Python code in the form of multiple arguments<br>
Note 2: For multiline code, make sure all the number of spaces you use for each indentation are consistent.<br>
<br>
Node 3: A history of recently ran commands  can be accessed through the variable <code>history</code> located within this object.]]></Description>
			<AdditionalClassCode><![CDATA[private static final String[][] condaPaths = new String[][]{
	{"Library", "mingw-w64", "bin"},
	{"Library", "usr", "bin"},
	{"Library", "bin"},
	{"Scripts"},
	{"bin"}
};

private enum ObjectAgentType {
	JAVA, // pure java type
	AGENT_SINGLE, // single agent
	AGENT_POPULATION, // anylogic-population (of agents)
	AGENT_COLLECTION // java collection with agent-typed components
}

/**
Initialize the PyCommunicator object with an abbreviated constructor.<br><br>
<b>Use case:</b> when wanting to load all settings from the stored configuration file.<br><br>
Defaults to throwing an error when a Python command fails and redirecting Python output to the AnyLogic console.<br><br>
@param loadLastWorkingConfig whether to use the configuration from the last working setup (pass true) or the default settings (pass false)
**/
public PyCommunicator(boolean loadLastWorkingConfig) {
	this(true, loadLastWorkingConfig, PythonCommandType.PYTHON, null, null, true, true);
}

/**
Initialize the PyCommunicator object with an abbreviated constructor.<br><br>
<b>Use case:</b> when wanting to call Python with one of the built-in aliases.<br><br>
Defaults to throwing an error when a Python command fails and redirecting Python output to the AnyLogic console.<br><br>
@param pythonCommandType the option for the desired Python command 
	(<code>PYTHON</code> for <code>`python`</code>, <code>PYTHON2</code> for <code>`python2`, or <code>PYTHON3</code> for <code>`python3`</code>)
**/
public PyCommunicator(PythonCommandType pythonCommandType) {
	this(true, false, pythonCommandType, null, null, true, true);
}

/**
Initialize the PyCommunicator object with an abbreviated constructor.<br><br>
<b>Use case:</b> when wanting to call Python with one of the built-in aliases and to specify further parameter options.<br><br>
@param pythonCommandType the option for the desired Python command 
	(<code>PYTHON</code> for <code>`python`</code>, <code>PYTHON2</code> for <code>`python2`</code>, or <code>PYTHON3</code> for <code>`python3`</code>)
@param throwErrorOnFailedAttempt whether to throw an error when a Python command fails
@param redirectPyOutput whether to pipe prints, warnings, and errors from Python to the AnyLogic console
**/
public PyCommunicator(PythonCommandType pythonCommandType, boolean throwErrorOnFailedAttempt, boolean redirectPyOutput) {
	this(true, false, pythonCommandType, "", "", throwErrorOnFailedAttempt, redirectPyOutput);
}

/**
Initialize the PyCommunicator object with an abbreviated constructor.<br><br>
<b>Use case:</b> when wanting to call Python with a custom command alias <i>or</i> by specifying the path to an executable.<br><br>
Defaults to throwing an error when a Python command fails and redirecting Python output to the AnyLogic console.<br><br>
@param pythonCommandType the option for the desired Python command
	(<code>PYTHON_OTHER</code> for a custom command or <code>PYTHON_PATH</code> to specify the full path)
@param otherCommandOrPath the custom command or full path of the desired Python to execute
**/
public PyCommunicator(PythonCommandType pythonCommandType, String otherCommandOrPath) {
	this(true, false, 
		pythonCommandType, 
		pythonCommandType.equals(PYTHON_OTHER) ? otherCommandOrPath : null, 
		pythonCommandType.equals(PYTHON_PATH) ? otherCommandOrPath : null, 
		true,
		true);
}

/**
Initialize PyCommunicator object from the preferred version and an argument.<br><br>
<b>Use case:</b> when wanting to call Python with a custom command alias <i>or</i> by specifying the path to an executable, 
and wanting to specify further parameter options.<br><br>
@param pythonCommandType the option for the desired Python command
	(<code>PYTHON_OTHER</code> for a custom command or <code>PYTHON_PATH</code> to specify the full path)
@param otherCommandOrPath the custom command or full path of the desired Python to execute
@param throwErrorOnFailedAttempt whether to throw an error when a Python command fails
@param redirectPyOutput whether to pipe prints, warnings, and errors from Python to the AnyLogic console
**/
public PyCommunicator(PythonCommandType pythonCommandType, String otherCommandOrPath, boolean throwErrorOnFailedAttempt, boolean redirectPyOutput) {
	this(true, false, 
		pythonCommandType, 
		pythonCommandType.equals(PYTHON_OTHER) ? otherCommandOrPath : null, 
		pythonCommandType.equals(PYTHON_PATH) ? otherCommandOrPath : null, 
		throwErrorOnFailedAttempt,
		redirectPyOutput);
}

/**
Initialize PyCommunicator object with the default JSON information and specified Python information
*/
public PyCommunicator(boolean enable, boolean loadLast, PythonCommandType pythonCommandType, String otherCommandOrPath, String execPath, boolean throwError, boolean redirect) {
	this(true, true, true, false, null, null, null, null, null, null, 
		enable, loadLast, pythonCommandType, otherCommandOrPath, execPath, throwError, redirect
		);
}

static HashMap<String, Object> serializeHistogram1DData(HistogramData h1data) {
	HashMap<String, Object> dataTable = new HashMap<>();

	int count = h1data.count();
	dataTable.put("count", count);
	// Follow similar structure as in ALCloud: User can derive ranges based on min X and interval width
	dataTable.put("lowerBound", h1data.getXMin());
	dataTable.put("intervalWidth", h1data.getIntervalWidth());
	int[] hits = IntStream.range(0, h1data.getNumberOfIntervals())
			.map(i -> Math.round((float)h1data.getPDF(i)*count)).toArray();
	dataTable.put("hits", hits);
	// HSimpleData = User set explicit min/max. There may be data outside this range, so add counts of lower/upper range of interval
	if (h1data instanceof HistogramSimpleData) {
		HistogramSimpleData hdataSimple = (HistogramSimpleData) h1data;
		dataTable.put("hitsOutLow", Math.round((float)hdataSimple.getPDFOutsideLow()*count));
		dataTable.put("hitsOutHigh", Math.round((float)hdataSimple.getPDFOutsideHigh()*count));
	}
	// Add in other useful stats available from histogram
	HashMap<String, Double> dtableStats = new HashMap<>();
	dtableStats.put("min", h1data.min());
	dtableStats.put("max", h1data.max());
	dtableStats.put("mean", h1data.mean());
	dtableStats.put("deviation", h1data.deviation());
	dataTable.put("statistics", dtableStats);
	
	return dataTable;
	
}

static HashMap<String, Object> serializeHistogram2DData(Histogram2DData h2data) {
	HashMap<String, Object> dataTable = new HashMap<>();

	// Follow similar structure as in ALCloud; user can derive interval size, etc. from available data
	int nX = h2data.getNumberOfXIntervals();
	int nY = h2data.getNumberOfYIntervals();
	int[][] hits = new int[nY][nX];
	int[] hitsOutLow = new int[nX];
	int[] hitsOutHigh = new int[nX];
	for (int x = 0; x < nX; x++) {
		int xcount = h2data.count(x);
		hitsOutLow[x] = Math.round((float)h2data.getPDFOutsideLow(x)*xcount);
		hitsOutHigh[x] = Math.round((float)h2data.getPDFOutsideHigh(x)*xcount);
		for (int y = 0; y < nY; y++) {
			hits[y][x] = Math.round((float)h2data.getPDF(x, y)*xcount);
		}
	}
	dataTable.put("hits", hits);
	dataTable.put("hitsOutLow", hitsOutLow);
	dataTable.put("hitsOutHigh", hitsOutHigh);
	dataTable.put("xMin", h2data.getXMin());
	dataTable.put("xMax", h2data.getXMax());
	dataTable.put("yMin", h2data.getYMin());
	dataTable.put("yMax", h2data.getYMax());
	return dataTable;
}

static HashMap<String, Object> serializeStatisticsDiscrete(StatisticsDiscrete stat) {
	String[] statRows = stat.toString().split("\n");
	HashMap<String, Object> statMap = new HashMap<>();
	Arrays.stream(statRows)
		.map(s -> s.strip().split("\t"))
		.forEach(s -> statMap.put(s[0], Double.valueOf(s[1].replaceAll(",", ""))));
	return statMap;
}

static HashMap<String, Object> serializeStatisticsContinuous(StatisticsContinuous stat) {
	String[] statRows = stat.toString().split("\n");
	HashMap<String, Object> statMap = new HashMap<>();
	Arrays.stream(statRows)
		.map(s -> s.strip().split("\t"))
		.forEach(s -> statMap.put(s[0], Double.valueOf(s[1].replaceAll(",", ""))));
	return statMap;
}
]]></AdditionalClassCode>
			<Import><![CDATA[import com.anylogic.cloud.util.ExceptionUtils;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.URI;
import java.net.URISyntaxException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.Properties;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import spark.utils.IOUtils;]]></Import>
			<ExtendsReference>
				<PackageName><![CDATA[com.anylogic.libraries.pypeline]]></PackageName>
				<ClassName><![CDATA[Jsonifier]]></ClassName>
			</ExtendsReference>
			<Parameters>
				<Parameter>
					<Name><![CDATA[isBlacklistMode]]></Name>
				</Parameter>
				<Parameter>
					<Name><![CDATA[isCustomConfiguration]]></Name>
				</Parameter>
				<Parameter>
					<Name><![CDATA[includeAutogeneratedsBL]]></Name>
				</Parameter>
				<Parameter>
					<Name><![CDATA[includeAutogeneratedsWL]]></Name>
				</Parameter>
				<Parameter>
					<Name><![CDATA[includedPackagesBL]]></Name>
				</Parameter>
				<Parameter>
					<Name><![CDATA[includedPackagesWL]]></Name>
				</Parameter>
				<Parameter>
					<Name><![CDATA[includedClassesBL]]></Name>
				</Parameter>
				<Parameter>
					<Name><![CDATA[includedClassesWL]]></Name>
				</Parameter>
				<Parameter>
					<Name><![CDATA[includedNamesBL]]></Name>
				</Parameter>
				<Parameter>
					<Name><![CDATA[includedNamesWL]]></Name>
				</Parameter>
			</Parameters>
			<StartupCode><![CDATA[if (enable) connect();]]></StartupCode>
			<DestroyCode><![CDATA[// Allow the existing Python environment to die gracefully
try {
	// Kill any still active background processes (from running headless files)
	headlessAttempts.forEach(a -> a.cancel(true));
	py.close();
} catch (NullPointerException e) {
	// ignore (problem with initializing `py`)
} catch (Exception e) {
	e.printStackTrace();
}]]></DestroyCode>
			<Generic>false</Generic>
			<GenericParameter>
				<Id>1569858524853</Id>
				<Name><![CDATA[1569858524853]]></Name>
				<GenericParameterValue Class="CodeValue">
					<Code><![CDATA[T extends Agent]]></Code>
				</GenericParameterValue>
				<GenericParameterLabel><![CDATA[Generic parameter:]]></GenericParameterLabel>
			</GenericParameter>
			<FlowchartBlock>true</FlowchartBlock>
			<FlowChartsUsage>ENTITY</FlowChartsUsage>
			<SamplesToKeep>100</SamplesToKeep>
			<LimitNumberOfArrayElements>false</LimitNumberOfArrayElements>
			<ElementsLimitValue>100</ElementsLimitValue>
			<MakeDefaultViewArea>true</MakeDefaultViewArea>
			<SceneGridColor/>
			<SceneBackgroundColor/>
			<SceneSkybox>null</SceneSkybox>
			<AgentProperties>
				<EnvironmentDefinesInitialLocation>true</EnvironmentDefinesInitialLocation>
				<RotateAnimationTowardsMovement>true</RotateAnimationTowardsMovement>
				<RotateAnimationVertically>false</RotateAnimationVertically>
				<VelocityCode Class="CodeUnitValue">
					<Code><![CDATA[10]]></Code>
					<Unit Class="SpeedUnits"><![CDATA[MPS]]></Unit>
				</VelocityCode>
				<PhysicalLength Class="CodeUnitValue">
					<Code><![CDATA[1]]></Code>
					<Unit Class="LengthUnits"><![CDATA[METER]]></Unit>
				</PhysicalLength>
				<PhysicalWidth Class="CodeUnitValue">
					<Code><![CDATA[1]]></Code>
					<Unit Class="LengthUnits"><![CDATA[METER]]></Unit>
				</PhysicalWidth>
				<PhysicalHeight Class="CodeUnitValue">
					<Code><![CDATA[1]]></Code>
					<Unit Class="LengthUnits"><![CDATA[METER]]></Unit>
				</PhysicalHeight>
			</AgentProperties>
			<EnvironmentProperties>
					<EnableSteps>false</EnableSteps>
					<StepDurationCode Class="CodeUnitValue">
						<Code><![CDATA[1.0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[SECOND]]></Unit>
					</StepDurationCode>
					<SpaceType>CONTINUOUS</SpaceType>
					<WidthCode><![CDATA[500]]></WidthCode>
					<HeightCode><![CDATA[500]]></HeightCode>
					<ZHeightCode><![CDATA[0]]></ZHeightCode>
					<ColumnsCountCode><![CDATA[100]]></ColumnsCountCode>
					<RowsCountCode><![CDATA[100]]></RowsCountCode>
					<NeigborhoodType>MOORE</NeigborhoodType>
					<LayoutType>USER_DEF</LayoutType>
					<LayoutTypeApplyOnStartup>true</LayoutTypeApplyOnStartup>
					<NetworkType>USER_DEF</NetworkType>
					<NetworkTypeApplyOnStartup>true</NetworkTypeApplyOnStartup>
					<ConnectionsPerAgentCode><![CDATA[2]]></ConnectionsPerAgentCode>
					<ConnectionsRangeCode><![CDATA[50]]></ConnectionsRangeCode>
					<NeighborLinkFractionCode><![CDATA[0.95]]></NeighborLinkFractionCode>
					<MCode><![CDATA[10]]></MCode>
			</EnvironmentProperties>
			<DatasetsCreationProperties>
				<AutoCreate>false</AutoCreate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1569916800000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[SECOND]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[SECOND]]></Unit>
					</RecurrenceCode>
			</DatasetsCreationProperties>
			<ScaleRuler>
				<Id>1569858524851</Id>
				<Name><![CDATA[scale]]></Name>
				<X>0</X><Y>-150</Y>
				<PublicFlag>false</PublicFlag>
				<PresentationFlag>false</PresentationFlag>
				<ShowLabel>false</ShowLabel>
				<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
				<Length>100</Length>
				<Rotation>0</Rotation>
				<ScaleType>BASED_ON_LENGTH</ScaleType>
				<ModelLength>10</ModelLength>
				<LengthUnits>METER</LengthUnits>
				<Scale>10</Scale>
				<InheritedFromParentAgentType>true</InheritedFromParentAgentType>
			</ScaleRuler>
			<CurrentLevel>1569858524854</CurrentLevel>
			<ConnectionsId>1569858524850</ConnectionsId>
			<Variables>
				<Variable Class="PlainVariable">
					<Id>1569878540323</Id>
					<Name><![CDATA[py]]></Name>
					<Description><![CDATA[An instance of the <code>PySubProcess</code> object]]></Description>
					<X>550</X><Y>70</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="private" StaticVariable="false">
						<Type><![CDATA[PySubProcess]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[null]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1574960246472</Id>
					<Name><![CDATA[PYTHON]]></Name>
					<X>-220</X><Y>390</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="true" AccessType="public" StaticVariable="true">
						<Type><![CDATA[PythonCommandType]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[PythonCommandType.PYTHON]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1574960293631</Id>
					<Name><![CDATA[PYTHON2]]></Name>
					<X>-220</X><Y>420</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="true" AccessType="public" StaticVariable="true">
						<Type><![CDATA[PythonCommandType]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[PythonCommandType.PYTHON2]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1574960297045</Id>
					<Name><![CDATA[PYTHON3]]></Name>
					<X>-220</X><Y>450</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="true" AccessType="public" StaticVariable="true">
						<Type><![CDATA[PythonCommandType]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[PythonCommandType.PYTHON3]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1574960298125</Id>
					<Name><![CDATA[PYTHON_OTHER]]></Name>
					<X>-220</X><Y>480</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="true" AccessType="public" StaticVariable="true">
						<Type><![CDATA[PythonCommandType]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[PythonCommandType.PYTHON_OTHER]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1589490530972</Id>
					<Name><![CDATA[PYTHON_PATH]]></Name>
					<X>-220</X><Y>510</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="true" AccessType="public" StaticVariable="true">
						<Type><![CDATA[PythonCommandType]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[PythonCommandType.PYTHON_PATH]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1589586802472</Id>
					<Name><![CDATA[PROPERTIES_FILENAME]]></Name>
					<X>550</X><Y>190</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="true" AccessType="public" StaticVariable="false">
						<Type><![CDATA[String]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA["pypeline.properties"]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="Parameter">
					<Id>1608072595259</Id>
					<Name><![CDATA[enable]]></Name>
					<X>-250</X><Y>330</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[boolean]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<SdArray>false</SdArray>
						<DefaultValue Class="CodeValue">
							<Code><![CDATA[true]]></Code>
						</DefaultValue>
						<OnChangeCode><![CDATA[if (enable)
	connect();
else
	disconnect();]]></OnChangeCode>
						<ParameterEditor>
							<Id>1608072595257</Id>
							<Label><![CDATA[Enable connection]]></Label>
							<EditorContolType>CHECK_BOX</EditorContolType>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
				<Variable Class="Parameter">
					<Id>1589488014296</Id>
					<Name><![CDATA[loadLastWorkingConfig]]></Name>
					<X>-250</X><Y>350</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[boolean]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<SdArray>false</SdArray>
						<DefaultValue Class="CodeValue">
							<Code><![CDATA[false]]></Code>
						</DefaultValue>
						<ParameterEditor>
							<Id>1589488014294</Id>
							<Label><![CDATA[Load last working configuration]]></Label>
							<EditorContolType>CHECK_BOX</EditorContolType>
							<HideCondition>
								<Id>0</Id>
								<ParameterId>1608072595259</ParameterId>
								<Operation>EQUALS</Operation>
								<Value Class="CodeValue">
									<Code><![CDATA[false]]></Code>
								</Value>
							</HideCondition>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>SEPARATOR</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
				<Variable Class="Parameter">
					<Id>1570726491560</Id>
					<Name><![CDATA[pythonCommandType]]></Name>
					<Description><![CDATA[The preferred command to call Python.<br>
If <i>(other)</i> is selected, you can specify the alias to Python.<br>
If <i>(path)</i> is selected, you can specify the full path to the desired python executable.
]]></Description>
					<X>-250</X><Y>370</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[com.anylogic.libraries.pypeline.PythonCommandType]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<SdArray>false</SdArray>
						<DefaultValue Class="CodeValue">
							<Code><![CDATA[self.PYTHON]]></Code>
						</DefaultValue>
						<ParameterEditor>
							<Id>1570726491558</Id>
							<Label><![CDATA[Command to call Python]]></Label>
							<EditorContolType>RADIO_BUTTONS</EditorContolType>
							<HideCondition>
								<Id>0</Id>
								<ParameterId>1608072595259</ParameterId>
								<Operation>EQUALS</Operation>
								<Value Class="CodeValue">
									<Code><![CDATA[false]]></Code>
								</Value>
							</HideCondition>
							<HideCondition>
								<Id>0</Id>
								<ParameterId>1589488014296</ParameterId>
								<Operation>EQUALS</Operation>
								<Value Class="CodeValue">
									<Code><![CDATA[true]]></Code>
								</Value>
							</HideCondition>
							<PredefParamValue>
								<Id>0</Id>
								<Name><![CDATA[python]]></Name>
								<Value Class="CodeValue">
									<Code><![CDATA[self.PYTHON]]></Code>
								</Value>
							</PredefParamValue>
							<PredefParamValue>
								<Id>0</Id>
								<Name><![CDATA[python3]]></Name>
								<Value Class="CodeValue">
									<Code><![CDATA[self.PYTHON3]]></Code>
								</Value>
							</PredefParamValue>
							<PredefParamValue>
								<Id>0</Id>
								<Name><![CDATA[(other)]]></Name>
								<Value Class="CodeValue">
									<Code><![CDATA[self.PYTHON_OTHER]]></Code>
								</Value>
							</PredefParamValue>
							<PredefParamValue>
								<Id>0</Id>
								<Name><![CDATA[(path)]]></Name>
								<Value Class="CodeValue">
									<Code><![CDATA[self.PYTHON_PATH]]></Code>
								</Value>
							</PredefParamValue>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>SEPARATOR</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
				<Variable Class="Parameter">
					<Id>1589488235619</Id>
					<Name><![CDATA[pythonCommand]]></Name>
					<Description><![CDATA[The full path to the desired python executable.<br>
The input of this parameter is used when <code>pythonCommandType</code> is set to "(other)" / <code>PythonCommandType.PYTHON_OTHER</code>.<br>
For other settings, this parameter's value will be updated to reflect the executable path of the active Python being used.]]></Description>
					<X>-250</X><Y>540</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[String]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<SdArray>false</SdArray>
						<DefaultValue Class="CodeValue">
							<Code><![CDATA[// e.g., "python38"]]></Code>
						</DefaultValue>
						<ParameterEditor>
							<Id>1589488235617</Id>
							<Label><![CDATA[Python command]]></Label>
							<EditorContolType>TEXT_BOX</EditorContolType>
							<HideCondition>
								<Id>0</Id>
								<ParameterId>1608072595259</ParameterId>
								<Operation>EQUALS</Operation>
								<Value Class="CodeValue">
									<Code><![CDATA[false]]></Code>
								</Value>
							</HideCondition>
							<HideCondition>
								<Id>1589488235615</Id>
								<ParameterId>1570726491560</ParameterId>
								<Operation>NOT_EQUALS</Operation>
								<Value Class="CodeValue">
									<Code><![CDATA[self.PYTHON_OTHER]]></Code>
								</Value>
							</HideCondition>
							<HideCondition>
								<Id>1589488235616</Id>
								<ParameterId>1589488014296</ParameterId>
								<Operation>EQUALS</Operation>
								<Value Class="CodeValue">
									<Code><![CDATA[true]]></Code>
								</Value>
							</HideCondition>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
				<Variable Class="Parameter">
					<Id>1578675862658</Id>
					<Name><![CDATA[pythonExecPath]]></Name>
					<Description><![CDATA[The absolute path to the Python executable that is desired to be connected to.<br>
The input of this parameter is used when <code>pythonCommandType</code> is set to "(path)" / <code>PythonCommandType.PYTHON_PATH</code>.<br>
For other settings, this parameter's value will be updated to reflect the executable path of the active Python being used.
]]></Description>
					<X>-250</X><Y>560</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[String]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<SdArray>false</SdArray>
						<DefaultValue Class="CodeValue">
							<Code><![CDATA[// e.g., "C:\\anaconda3\\envs\\MyEnv\\python.exe"]]></Code>
						</DefaultValue>
						<ParameterEditor>
							<Id>1578675862656</Id>
							<Label><![CDATA[Python executable path]]></Label>
							<EditorContolType>TEXT_BOX</EditorContolType>
							<HideCondition>
								<Id>0</Id>
								<ParameterId>1608072595259</ParameterId>
								<Operation>EQUALS</Operation>
								<Value Class="CodeValue">
									<Code><![CDATA[false]]></Code>
								</Value>
							</HideCondition>
							<HideCondition>
								<Id>0</Id>
								<ParameterId>1570726491560</ParameterId>
								<Operation>NOT_EQUALS</Operation>
								<Value Class="CodeValue">
									<Code><![CDATA[self.PYTHON_PATH]]></Code>
								</Value>
							</HideCondition>
							<HideCondition>
								<Id>0</Id>
								<ParameterId>1589488014296</ParameterId>
								<Operation>EQUALS</Operation>
								<Value Class="CodeValue">
									<Code><![CDATA[true]]></Code>
								</Value>
							</HideCondition>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
				<Variable Class="Parameter">
					<Id>1582299117563</Id>
					<Name><![CDATA[throwErrorOnFailedAttempt]]></Name>
					<Description><![CDATA[Decides whether to throw an AnyLogic model error if any command does not execute successfully.<br>
In other words: if set to true, errors from Python will cause model-halting errors in AnyLogic.<br>]]></Description>
					<X>-250</X><Y>580</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[boolean]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<SdArray>false</SdArray>
						<DefaultValue Class="CodeValue">
							<Code><![CDATA[true]]></Code>
						</DefaultValue>
						<ParameterEditor>
							<Id>1582299117561</Id>
							<Label><![CDATA[Throw error on failed attempt]]></Label>
							<EditorContolType>CHECK_BOX</EditorContolType>
							<HideCondition>
								<Id>0</Id>
								<ParameterId>1608072595259</ParameterId>
								<Operation>EQUALS</Operation>
								<Value Class="CodeValue">
									<Code><![CDATA[false]]></Code>
								</Value>
							</HideCondition>
							<HideCondition>
								<Id>0</Id>
								<ParameterId>1589488014296</ParameterId>
								<Operation>EQUALS</Operation>
								<Value Class="CodeValue">
									<Code><![CDATA[true]]></Code>
								</Value>
							</HideCondition>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
				<Variable Class="Parameter">
					<Id>1597358663336</Id>
					<Name><![CDATA[redirectPyOutput]]></Name>
					<Description><![CDATA[Whether to redirect output coming from Python to the AnyLogic console.<br>
If true, any print statements or warnings from Python will be printed to the AnyLogic console.<br>
When viewed from the developer panel, standard output will be printed in <span style="color:green;">green</span> and standard error will be printed in <span style="color:red;">red</span>.<br>
You may change this parameter during run-time to override the initial value.]]></Description>
					<X>-250</X><Y>600</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[boolean]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<SdArray>false</SdArray>
						<DefaultValue Class="CodeValue">
							<Code><![CDATA[true]]></Code>
						</DefaultValue>
						<OnChangeCode><![CDATA[if (py != null)
	py.redirectPyOutput = redirectPyOutput;]]></OnChangeCode>
						<ParameterEditor>
							<Id>1597358663334</Id>
							<Label><![CDATA[Redirect Python output]]></Label>
							<EditorContolType>CHECK_BOX</EditorContolType>
							<HideCondition>
								<Id>0</Id>
								<ParameterId>1608072595259</ParameterId>
								<Operation>EQUALS</Operation>
								<Value Class="CodeValue">
									<Code><![CDATA[false]]></Code>
								</Value>
							</HideCondition>
							<HideCondition>
								<Id>0</Id>
								<ParameterId>1589488014296</ParameterId>
								<Operation>EQUALS</Operation>
								<Value Class="CodeValue">
									<Code><![CDATA[true]]></Code>
								</Value>
							</HideCondition>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
				<Variable Class="CollectionVariable">
					<Id>1573064066321</Id>
					<Name><![CDATA[history]]></Name>
					<Description><![CDATA[Holds the last 500 commands ran by the user, in chronological order (i.e., the first item is the most recently run command).<br>
Implemented as a list of <code>Pair</code> objects with the command as the first value and the <code>Attempt</code> as the second value.<br>
For example, to get the code used in the most recent command: <code>history.get(0).getFirst()</code><br>
And to get the Attempt used in the most recent command: <code>history.get(0).getSecond()</code><br>
<br>
Provided as reference for the end-user; for example, if they execute multiple commands sequentially and want the outputs without having to create an object for each call.<br>]]></Description>
					<X>750</X><Y>430</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" AccessType="public" StaticVariable="false">
						<CollectionClass><![CDATA[LinkedList]]></CollectionClass>
						<ElementClass><![CDATA[Pair<String, Attempt>]]></ElementClass>
						<ValueElementClass><![CDATA[String]]></ValueElementClass>
					</Properties>

				</Variable>
				<Variable Class="CollectionVariable">
					<Id>1575321216484</Id>
					<Name><![CDATA[serverPyLines]]></Name>
					<Description><![CDATA[This file is written in the system's temporary file directory and how Python communicates with AnyLogic.]]></Description>
					<X>750</X><Y>490</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>false</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" AccessType="private" StaticVariable="false">
						<CollectionClass><![CDATA[ArrayList]]></CollectionClass>
						<ElementClass><![CDATA[String]]></ElementClass>
						<ValueElementClass><![CDATA[String]]></ValueElementClass>
						<CollectionInitializer Class="CodeValue">
							<Code><![CDATA[{
"import os",
"import socket",
"import sys",
"import json",
"from json.decoder import JSONDecodeError",
"import struct",
"import traceback",
"",
"LEN_SIZE = 10",
"TYPE_SIZE = 1",
"",
"# In",
"EXEC_MSG = 0",
"EVAL_MSG = 1",
"PING_MSG = 2",
"",
"# Out",
"SUCC_MSG = 0",
"ERR_MSG = 1",
"EMPTY_RESULT = ''",
"",
"def print_err(s):",
"    sys.stderr.write('{}\\n'.format(s))",
"    sys.stderr.flush()",
"",
"class ConnectionReader:",
"    def __init__(self, conn):",
"        self.conn = conn",
"        self.buff = bytearray()",
"",
"    def _get_packet(self):",
"        data = self.conn.recv(1024)",
"        if not data:",
"            raise EOFError('Connection closed')",
"        return data",
"",
"    def read(self, size):",
"        while len(self.buff) < size:",
"            self.buff.extend(self._get_packet())",
"        result = bytes(self.buff[:size])",
"        del self.buff[:size]",
"        return result",
"",
"    def read_json(self):",
"        return json.loads(r'{}'.format(self.read_string()))",
"",
"    def read_int(self):",
"        return struct.unpack('>i', self.read(4))[0]",
"",
"    def read_byte(self):",
"        return struct.unpack('b', self.read(1))[0]",
"",
"    def read_string(self):",
"        length = self.read_int()",
"        bin_data = self.read(length)",
"        try:",
"            str_data = bin_data.decode(\"utf-8\")",
"        except UnicodeDecodeError:",
"            str_data = bin_data.decode(\"ISO-8859-1\")",
"        return str_data",
"",
"",
"class ConnectionWriter:",
"    def __init__(self, conn):",
"        self.conn = conn",
"        self.buff = bytearray()",
"",
"    def write(self, data):",
"        self.buff.extend(data)",
"",
"    def write_byte(self, b):",
"        self.write(struct.pack('b', b))",
"",
"    def write_int(self, i):",
"        self.write(struct.pack('>i', i))",
"",
"    def write_string(self, s):",
"        bs = to_bytes(s)",
"        self.write_int(len(bs))",
"        self.write(bs)",
"",
"    def flush(self):",
"        self.conn.sendall(self.buff)",
"        self.clear()",
"",
"    def clear(self):",
"        self.buff = bytearray()",
"",
"",
"def utf8(bs):",
"    if sys.version_info >= (3, 0):",
"        return str(bs, 'UTF8')",
"    return unicode(bs, 'UTF8')",
"",
"",
"def to_bytes(s):",
"    if type(s) == bytes:",
"        return s",
"",
"    if type(s) != str:",
"        s = str(s)",
"",
"    if sys.version_info >= (3, 0):",
"        return bytes(s, 'UTF8')",
"    return bytes(s)",
"",
"",
"def responder():",
"    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)",
"    try:",
"        sock.bind(('localhost', 0))",
"        sock.listen(0)",
"        _, port = sock.getsockname()",
"        sys.stdout.write('{}\\n'.format(port))",
"        sys.stdout.flush()",
"        conn, addr = sock.accept()",
"        try:",
"            inp = ConnectionReader(conn)",
"            out = ConnectionWriter(conn)",
"            globs = {}",
"            while True:",
"                msg_type = int(inp.read_byte())",
"                try:",
"                    if msg_type == EXEC_MSG: # 0 (just run)",
"                        code = inp.read_string()",
"                        exec(code, globs)",
"                        out.write_byte(SUCC_MSG)",
"                        out.write_string(EMPTY_RESULT)",
"                    elif msg_type == EVAL_MSG: # 1 (run and return)",
"                        code = inp.read_string()",
"                        try:",
"                            result = eval(code, globs)",
"                        except NameError as n_err: # assume json",
"                            try:",
"                                result = json.loads(r'{}'.format(code))",
"                            except JSONDecodeError as j_err:",
"                                raise Exception('The following line failed to parse (as strictly Python or JSON-parsed code):'",
"                                                + '\\n    `{}`'.format(code)",
"												 + '\\nConsider one of the following reasons:'",
"                                                + '\\n1. Python reason: {}'.format(n_err)",
"                                                + '\\n2. JSON   reason: {}'.format(j_err))",
"                        out.write_byte(SUCC_MSG)",
"                        out.write_string(result)",
"                    elif msg_type == PING_MSG: # 2 (testing)",
"                        out.write_byte(SUCC_MSG)",
"                        out.write_string(EMPTY_RESULT)",
"                    else:",
"                        raise Exception('Unrecognized message type: {}'.format(msg_type))",
"                except Exception as e:",
"                    traceback.print_exc()",
"                    out.write_byte(ERR_MSG)",
"                    out.write_string(repr(e))",
"                finally:",
"                    out.flush()",
"                    flush()",
"        finally:",
"            conn.close()",
"    finally:",
"        sock.close()",
"",
"def flush():",
"    sys.stdout.flush()",
"    sys.stderr.flush()",
"",
"if __name__ == '__main__':",
"    sys.path.insert(0, os.getcwd())",
"    responder()",
""
}]]></Code>
						</CollectionInitializer>
					</Properties>

				</Variable>
				<Variable Class="CollectionVariable">
					<Id>1685473152541</Id>
					<Name><![CDATA[headlessAttempts]]></Name>
					<X>870</X><Y>330</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" AccessType="default" StaticVariable="true">
						<CollectionClass><![CDATA[ArrayList]]></CollectionClass>
						<ElementClass><![CDATA[FutureAttempt]]></ElementClass>
						<ValueElementClass><![CDATA[String]]></ValueElementClass>
					</Properties>

				</Variable>
			</Variables>
			<Functions>
				<Function AccessType="public" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[Attempt]]></ReturnType>
					<Id>1569878590739</Id>
					<Name><![CDATA[run]]></Name>
					<Description><![CDATA[ Execute a statement ("just run" / no expected return)<br>
@param code The single line of code to be executed<br>
@return Attempt Contains no feedback if successful, otherwise the error message]]></Description>
					<X>750</X><Y>70</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[code]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Body><![CDATA[//logger.finer("ENTRY run(" + code + ")");

Attempt attempt = py.exec(code);
history.add(0, new Pair<>(code, attempt));
validateHistoryLimit();
if (throwErrorOnFailedAttempt && !attempt.isSuccessful()) {
	error("Failed to run python code; feedback: %s", attempt.getFeedback()); // new lines aren't printing properly, TODO - look into that
}

//logger.finer("EXIT run(" + attempt + ")");
return attempt;]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[Attempt]]></ReturnType>
					<Id>1569878595053</Id>
					<Name><![CDATA[run]]></Name>
					<Description><![CDATA[ Execute a statement ("just run" / no expected return)<br>
@param lines The multi-lined code to run, with each line as its own argument<br>
@return Attempt Contains no feedback if successful, otherwise the error message]]></Description>
					<X>770</X><Y>90</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[lines]]></Name>
						<Type><![CDATA[String...]]></Type>
					</Parameter>
					<Body><![CDATA[String code = String.join("\n", lines);
return run(code);]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[Attempt]]></ReturnType>
					<Id>1569878710125</Id>
					<Name><![CDATA[runResults]]></Name>
					<Description><![CDATA[Evaluate an expression ("get value" / expecting a return)<br>
@param code The single line of code to be executed<br>
@return Attempt Contains the feedback of the returned value if no error, otherwise the error message]]></Description>
					<X>750</X><Y>150</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[code]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Body><![CDATA[Attempt attempt = py.eval(code);
history.add(0, new Pair<>(code, attempt));
validateHistoryLimit();
if (throwErrorOnFailedAttempt && !attempt.isSuccessful())
	error("Failed to run python code; feedback: %s", attempt.getFeedback());
return attempt;]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[Attempt]]></ReturnType>
					<Id>1569878750550</Id>
					<Name><![CDATA[runResults]]></Name>
					<Description><![CDATA[Evaluate an expression ("get value" / expecting a return)<br>
@param lines The multi-lined code to run, with each line as its own argument<br>
@return Attempt Contains the feedback of the returned value if no error, otherwise the error message]]></Description>
					<X>770</X><Y>170</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[lines]]></Name>
						<Type><![CDATA[String...]]></Type>
					</Parameter>
					<Body><![CDATA[String code = String.join("\n", lines);
return runResults(code);]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[boolean]]></ReturnType>
					<Id>1572989835347</Id>
					<Name><![CDATA[isConnected]]></Name>
					<Description><![CDATA[Attempts to ping the Python server to see if it's still alive and ready to receive commands<br>
@return boolean whether the ping was successful]]></Description>
					<X>750</X><Y>390</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[if (py == null)
	return false;
	
Attempt attempt = py.ping();

if (throwErrorOnFailedAttempt && !attempt.isSuccessful())
	error(attempt.getFeedback());

return attempt.isSuccessful();]]></Body>
				</Function>
				<Function AccessType="private" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[String]]></ReturnType>
					<Id>1575321216486</Id>
					<Name><![CDATA[createServerPy]]></Name>
					<Description><![CDATA[Creates the server Python file
@return String Path to the server file]]></Description>
					<X>750</X><Y>510</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>false</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[try {
	java.nio.file.Path tmpFile = Files.createTempFile("pypeline-server_", ".py");
	tmpFile.toFile().deleteOnExit();
	BufferedWriter writer = new BufferedWriter(new FileWriter(tmpFile.toFile()));
	for (String line : serverPyLines)
    	writer.write(line + "\n");
    writer.close();
	return tmpFile.toString();
} catch (IOException e) {
	e.printStackTrace();
}
return null;]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[String]]></ReturnType>
					<Id>1581007322208</Id>
					<Name><![CDATA[toString]]></Name>
					<Description><![CDATA[Convert this object (PyCommunicator) to a human readable string of text.<br>
This is the text that appears when you print the object to the console and also what appears in the inspection window when you click on the icon during a running model.
@return the complete Python version (major.minor.patch) and path to Python executable (separated by a newline) if Python is connected to, otherwise "null"]]></Description>
					<X>550</X><Y>330</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[return py == null ? "null" : py.activePyVersion + "\n" + py.activePyPath;]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1581016103424</Id>
					<Name><![CDATA[initialize]]></Name>
					<Description><![CDATA[Uses the currently set parameter values to initialize the Python environment.<br>
The parameters will be loaded from properties or the last working configuration if desired (i.e., <code>loadLastWorkingConfig</code> is set to true).<br>
Based on the type of command (i.e., value of <code>pythonCommandType</code>), the path parameter (<code>pythonExecPath</code>) will be attempted to be found before creating the Python subproces.<br>
If there is already a running Python environment, this will first try to close it gracefully before creating a new environment.<br>
@throws RuntimeException If the path to Python executable cannot be found or was not provided, if a directory was passed and there are zero or more than one 'python' executables, or if there was a problem with setting up the Python subprocess]]></Description>
					<X>550</X><Y>90</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[// Allow the existing Python environment (if one is created) to die gracefully
if (py != null) {
	try {
		py.close();
	} catch (Exception e) {
		e.printStackTrace();
	}
}

if (loadLastWorkingConfig) {
	importProperties();
}

// Handle variations of [largely problematic] inconsistencies by throwing an error
if (pythonCommandType.equals(PYTHON_OTHER) && pythonCommand == null) {
	error("Type was set to 'other' [alias] but no alternate alias was provided!");
} else if (pythonCommandType.equals(PYTHON_PATH) && pythonExecPath == null) {
	error("Type was set to [custom] 'path' but no path was provided!");
}

// Synchronize parameters based on provided parameters
String pathToServerPy = createServerPy();
switch (pythonCommandType) {
	case PYTHON:
	case PYTHON2:
	case PYTHON3:
		String newCommand = PySubProcess.convertToCommand(pythonCommandType);
		// Handle variations of [minimally problematic] inconsistencies by warning user.
		if (pythonCommand != null && !pythonCommand.equals(newCommand)) {
			warning("Overriding previous Python command (%s) with corrected command (%s), based on set command type.", pythonCommand, newCommand);
		}
		set_pythonCommand(newCommand);
		// don't break; also set the exec path
	case PYTHON_OTHER:
		String newExecPath = null;
		try {
			newExecPath = PySubProcess.findPythonPath(pythonCommand);
			// Handle variations of [minimally problematic] inconsistencies by warning user.
			if (pythonExecPath != null && !pythonExecPath.equals(newExecPath)) {
				warning("Overriding previous Python executable path (%s) with corrected path (%s), based on set command type.", pythonExecPath, newExecPath);
			}
		} catch (PyException e) {
			error(e, "Failed to find Python executable path based on Python command: " + String.format(pythonCommand));
		}
		set_pythonExecPath(newExecPath);
	case PYTHON_PATH:
		break;
}

// The executable path is a requirement. If it's not found, throw an error.
if (pythonExecPath == null) {
	String prefInput = pythonCommandType.toString() + (pythonCommandType.equals(PYTHON_OTHER) ? " - '"+pythonCommand+"'" : "");

	String msg = "Could not find any Python executable based on your preferred input (" + prefInput + ").";
	msg += "\nPlease check your system or user \"PATH\" variable. This can be printed out in AnyLogic by executing the code: `traceln(System.getenv(\"PATH\"));`";
	msg += "\nNote: If you modify the path variable, you may need to restart AnyLogic for the changes to take effect.";
	error(msg);
}


File f = new File(pythonExecPath);
// Handle when the executable cannot be found or accessed.
if (!f.exists()) { // passed executable path is not found, throw an error.
	boolean autodetected = !pythonCommandType.equals(PYTHON_PATH);
	String msg = (autodetected ? "Autodetected" : "Specified") + " Python (at " + pythonExecPath + ") ";
	
	boolean isWinStore = pythonExecPath.contains("Microsoft\\WindowsApps");
	if (isWinStore) {
		msg += "is from the Microsoft App store, but non-Microsoft programs do not have executable permissions; use a non-Microsoft version of Python.";
		msg += "\nIf you have one installed, configure your user PATH or disable App store aliases to Python in your settings app.";
		msg += "\nNote: If you modify the path variable, you may need to restart AnyLogic for the changes to take effect.";
	} else {
		msg += "cannot be found or accessed.";
		if (autodetected) {
			// likely a permissions error
			msg += " There may be a permissions issue or problem with the alias.";
		} else {
			// likely a typo
			msg += " Check the path for typos or the permissions of the specified executable.";
		}
	}
	error(msg);
} else if (!f.isFile()) {
	// user pasted a directory. Check for python.exe or just python
	File[] potentials = f.listFiles((dir, name) -> name.toLowerCase().equals("python.exe") || name.toLowerCase().equals("python"));
	// Fail if there are no results or > 1 result (i.e., ambiguous option)
	if (potentials.length != 1) {
		String msg = "The specified path to the Python executable is not a file: " + pythonExecPath;
		msg += "\nTried to find 'python.exe' or 'python', but couldn't locate a **single** result!";
		msg += "\nPlease append the desired executable and try again.";
		error(msg);
	}
	// update with corrected path
	set_pythonExecPath(potentials[0].getAbsolutePath());
}

try {
	py = new PySubProcess(pathToServerPy, pythonExecPath, redirectPyOutput, null); //LOG_LEVEL);
	modifyPathAsNeeded();
} catch (Exception e) {
	error(e, "Problem with setting up Python Subprocess");
}]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[Attempt]]></ReturnType>
					<Id>1581016194646</Id>
					<Name><![CDATA[runFile]]></Name>
					<Description><![CDATA[Execute a Python file and get the output.<br>
@param preferredVersion One of the options for which Python version to run the file<br>
@param args The file path and any arguments to run (flags and values should be separate strings)<br>
@return Attempt with any outputs from running the file]]></Description>
					<X>750</X><Y>290</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[preferredVersion]]></Name>
						<Type><![CDATA[PythonCommandType]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[args]]></Name>
						<Type><![CDATA[Object...]]></Type>
					</Parameter>
					<Body><![CDATA[ProcessBuilder pb = buildRunFileProcess(preferredVersion, args);
String output = "";
String error = "";

try {
	Process proc = pb.start();
	output = IOUtils.toString(proc.getInputStream()).trim();
	error = IOUtils.toString(proc.getErrorStream()).trim();
} catch (IOException | NullPointerException e) {
	String msg = String.format("Exception with running the command: `%s`\nStack trace is as follows:\n%s",
		String.join(" ", pb.command()),
		ExceptionUtils.toStringStackTrace(e));
	return new Attempt(Attempt.RESULT_ERROR, msg);
}

Attempt attempt;
if (error.isEmpty()) {
	attempt = new Attempt(Attempt.RESULT_SUCCESSFUL, output);
} else {
	attempt = new Attempt(Attempt.RESULT_ERROR, error);
}
	
return attempt;]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[Attempt]]></ReturnType>
					<Id>1581020688077</Id>
					<Name><![CDATA[runFile]]></Name>
					<Description><![CDATA[Execute a Python file using the preferred version of the running environment.<br>
@param args The file path, and any arguments to run (flags and values should be separate strings)<br>
@return Attempt with any outputs from running the file]]></Description>
					<X>750</X><Y>330</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[args]]></Name>
						<Type><![CDATA[Object...]]></Type>
					</Parameter>
					<Body><![CDATA[Object[] tmp = new Object[args.length+1];
tmp[0] = py.activePyPath;
System.arraycopy(args, 0, tmp, 1, args.length);

Attempt attempt = PyCommunicator.runFile(PythonCommandType.PYTHON_PATH, tmp);
history.add(0, new Pair<String,Attempt>(Arrays.toString(tmp), attempt));
validateHistoryLimit();
return attempt;]]></Body>
				</Function>
				<Function AccessType="private" StaticFunction="false">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1582829555051</Id>
					<Name><![CDATA[validateHistoryLimit]]></Name>
					<Description><![CDATA[Continues to remove the last entry in `history` until its size is at/under 500.]]></Description>
					<X>750</X><Y>450</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[while (history.size() > 500)
	history.removeLast();]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1588104859912</Id>
					<Name><![CDATA[importProperties]]></Name>
					<Description><![CDATA[Tries to import the properties file and load it into the model's parameters; if the properties file does not exist, the `generateProperties` function is called.<br>
The default properties file is named "pypeline.properties" and is located next to the Pypeline jar file.]]></Description>
					<X>550</X><Y>230</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[Properties prop = getSavedProperties();
if (prop == null) // nothing saved
	generateProperties();
	
set_enable(
	Boolean.valueOf(prop.getProperty("enable", "true")).booleanValue()
);
set_loadLastWorkingConfig(
	Boolean.valueOf(prop.getProperty("load_last", "false")).booleanValue()
);
set_pythonCommandType(
	PythonCommandType.valueOf(prop.getProperty("command_type"))
);
set_pythonCommand(
	prop.getProperty("command")
);
set_pythonExecPath(
	prop.getProperty("exec_path")
);
set_throwErrorOnFailedAttempt(
	Boolean.valueOf(prop.getProperty("throw_error_on_failed_attempt"))
);
set_redirectPyOutput(
	Boolean.valueOf(prop.getProperty("redirect_py_output", "true"))
);

jsonFilter.setMode(Boolean.valueOf(prop.getProperty("json_blacklist_mode", "true")), false);
jsonFilter.setAutogenerated(Boolean.valueOf(prop.getProperty("json_generated_option", "true")));
// clear each property then add it back in manually
jsonFilter.clearNames();
jsonFilter.includeNames(prop.getProperty("json_name_filter", "").split(","));

jsonFilter.clearClasses();
for (String clz : prop.getProperty("json_class_filter", "").split(",")) {
	try { // runs verification
		jsonFilter.includeClasses(Class.forName(clz));
	} catch (ClassNotFoundException e) {
		warning("Class listed in filter but not found: %s", clz);
	}
}

jsonFilter.clearPackages();
jsonFilter.includePackages(prop.getProperty("json_package_filter", "").split(","));]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1588105438239</Id>
					<Name><![CDATA[generateProperties]]></Name>
					<Description><![CDATA[Builds the properties file at the default properties path (<code>getDefaultPropertiesPath</code>) and saves the current parameter values.]]></Description>
					<X>550</X><Y>270</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[String newFilePath = getDefaultPropertiesPath();
try {
	OutputStream output = new FileOutputStream(newFilePath);
    Properties prop = new Properties();

    // set the properties value
    prop.setProperty("enable", String.valueOf(enable));
    prop.setProperty("load_last", String.valueOf(loadLastWorkingConfig));
    prop.setProperty("command_type", String.valueOf(pythonCommandType));
    prop.setProperty("command", String.valueOf(pythonCommand));
    prop.setProperty("exec_path", String.valueOf(pythonExecPath));
    prop.setProperty("throw_error_on_failed_attempt", String.valueOf(throwErrorOnFailedAttempt));
	prop.setProperty("redirect_py_output", String.valueOf(redirectPyOutput));
	prop.setProperty("json_blacklist_mode", String.valueOf(jsonFilter.isInBlacklistMode()));
	prop.setProperty("json_generated_option", String.valueOf(jsonFilter.isAutogeneratedIncluded()));
	prop.setProperty("json_name_filter", jsonFilter.getIncludedNames().stream().collect(Collectors.joining(",")));
    prop.setProperty("json_class_filter", jsonFilter.getIncludedClasses().stream().map(s -> s.getName()).collect(Collectors.joining(",")));
    prop.setProperty("json_package_filter", jsonFilter.getIncludedPackages().stream().collect(Collectors.joining(",")));
    // save properties to project root folder
    prop.store(output, null);

} catch (FileNotFoundException fnf) {
	// no write access, just warn
	warning("The directory which Pypeline's jar file resides in does not have write access; properties file cannot be generated.");
} catch (IOException io) {
    io.printStackTrace();
}]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[String]]></ReturnType>
					<Id>1589485728564</Id>
					<Name><![CDATA[getDefaultPropertiesPath]]></Name>
					<Description><![CDATA[@return The path to the properties file<br>
<br>
Note: The path will change based on where the exported library jar is stored (as the properties is designed to be generated next to the library jar file).]]></Description>
					<X>550</X><Y>250</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[String file = PROPERTIES_FILENAME;
try {
	URI parentURI = this.getClass().getProtectionDomain().getCodeSource().getLocation().toURI().resolve(".");
	String parentPath = Paths.get(parentURI).toString();
	file = Paths.get(parentPath, file).toString();
} catch (URISyntaxException ex) {
	ex.printStackTrace();
}
return file;]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[T]]></ReturnType>
					<Id>1598564953670</Id>
					<Name><![CDATA[runResults]]></Name>
					<Description><![CDATA[Evaluate an expression ("get value" / expecting a return)<br>
@param returnType The Java class of the return type<br>
@param code The single line of code to be executed<br>
@return T The output, in the type specified]]></Description>
					<CustomModifierCode><![CDATA[public <T>]]></CustomModifierCode>                 	
					<X>750</X><Y>210</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[returnType]]></Name>
						<Type><![CDATA[Class<T>]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[code]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Body><![CDATA[Attempt attempt = py.eval(code);
history.add(0, new Pair<>(code, attempt));
validateHistoryLimit();
if (throwErrorOnFailedAttempt && !attempt.isSuccessful())
	error("Failed to run python code; feedback: %s", attempt.getFeedback());
return attempt.getFeedback(returnType);]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[T]]></ReturnType>
					<Id>1598565117046</Id>
					<Name><![CDATA[runFile]]></Name>
					<Description><![CDATA[Execute a Python file and get the output.<br>
@param returnType The Java class of the return type<br>
@param preferredVersion One of the options for which Python version to run the file<br>
@param args The file path and any arguments to run (flags and values should be separate strings)<br>
@return T The output, in the type specified]]></Description>
					<CustomModifierCode><![CDATA[public static <T>]]></CustomModifierCode>                 	
					<X>770</X><Y>310</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[returnType]]></Name>
						<Type><![CDATA[Class<T>]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[preferredVersion]]></Name>
						<Type><![CDATA[PythonCommandType]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[args]]></Name>
						<Type><![CDATA[Object...]]></Type>
					</Parameter>
					<Body><![CDATA[Attempt attempt = runFile(preferredVersion, args);
return attempt.getFeedback(returnType);]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[T]]></ReturnType>
					<Id>1598565124530</Id>
					<Name><![CDATA[runFile]]></Name>
					<Description><![CDATA[Execute a Python file using the preferred version of the running environment.<br>
@param returnType The Java class of the return type<br>
@param args The file path, and any arguments to run (flags and values should be separate strings)<br>
@return T The output, in the type specified]]></Description>
					<CustomModifierCode><![CDATA[public <T>]]></CustomModifierCode>                 	
					<X>770</X><Y>350</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[returnType]]></Name>
						<Type><![CDATA[Class<T>]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[args]]></Name>
						<Type><![CDATA[Object...]]></Type>
					</Parameter>
					<Body><![CDATA[Attempt attempt = runFile(args);
return attempt.getFeedback(returnType);]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[T]]></ReturnType>
					<Id>1598565381265</Id>
					<Name><![CDATA[runResults]]></Name>
					<Description><![CDATA[Evaluate an expression ("get value" / expecting a return)<br>
@param returnType The Java class of the return type<br>
@param lines The multi-lined code to run, with each line as its own argument<br>
@return T The output, in the type specified]]></Description>
					<CustomModifierCode><![CDATA[public <T>]]></CustomModifierCode>                 	
					<X>770</X><Y>230</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[returnType]]></Name>
						<Type><![CDATA[Class<T>]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[lines]]></Name>
						<Type><![CDATA[String...]]></Type>
					</Parameter>
					<Body><![CDATA[String code = String.join("\n", lines);
return runResults(returnType, code);]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1600284468018</Id>
					<Name><![CDATA[modifyPathAsNeeded]]></Name>
					<Description><![CDATA[Anaconda environments (including its base) add specific folders inside the environment to the system path before calling Python. Because Pypeline works through a "normal" command-prompt, these are not added in by default.<br>
If the 'conda-meta' directory - present in all Anaconda environments - is located in the same folder as the provided executable, this function will add all the paths that Anaconda does. Like Anaconda, this may include directories that don't exist on the user's machine (has no effect, though).<br>]]></Description>
					<X>550</X><Y>290</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[// Check if this is a conda environment by looking for 'conda-meta' dir
// 	in same folder as executable path.
File execFile = new File(pythonExecPath);
File parentDir = execFile.getParentFile();
String[] siblingFilenames = parentDir.list();
boolean contains = Arrays.stream(siblingFilenames).anyMatch("conda-meta"::equals);
if (contains) {
	//traceln("Adding!");
	run("import os");
	String pathStrs = "";
	String base = parentDir.getAbsolutePath() + parentDir.separator;
	for (String[] pathParts : condaPaths) {
		pathStrs += base + String.join(parentDir.separator, pathParts);
		pathStrs += parentDir.pathSeparator;
	}
	//traceln("Adding: " + pathStrs);
	run(
		String.format(
			"os.environ['PATH'] = r'%s' + os.environ['PATH']",
			pathStrs
	));
	//traceln("Added: " + runResults(String.class, "os.environ['PATH']"));
} else {
	//traceln("Not adding!");
}]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="false">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1608072623170</Id>
					<Name><![CDATA[connect]]></Name>
					<Description><![CDATA[Connects to the local Python installation based on the currently set parameters.]]></Description>
					<X>550</X><Y>110</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[initialize();
generateProperties();]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="false">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1608072627145</Id>
					<Name><![CDATA[disconnect]]></Name>
					<Description><![CDATA[Disconnects from the local Python installation.<br>
Executing this function sever the connection to Python. To reconnect, the <code>connect</code> function will need to be called.]]></Description>
					<X>550</X><Y>130</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[// Allow the existing Python environment to die gracefully
try {
	py.close();
	// Then set the object to null
	py = null;
} catch (Exception e) {
	e.printStackTrace();
}
]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="false">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1608073708521</Id>
					<Name><![CDATA[reset]]></Name>
					<Description><![CDATA[First disconnects from the active Python installation, then reconnects to it.<br>
Executing this function sever the connection to Python and then reestablish it. This will create a fresh/clean Python environment using the same Python installation previously used.<br>
If it's desired to change the Python environment that's connected to, first call <code>disconnect</code>, then ]]></Description>
					<X>550</X><Y>150</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[disconnect();
connect();]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[Attempt]]></ReturnType>
					<Id>1608074835580</Id>
					<Name><![CDATA[run]]></Name>
					<Description><![CDATA[ Execute a statement ("just run" / no expected return)<br>
@param codeFmt The single line of code to be executed with String-formatted placeholders<br>
@param args The objects to replace the placeholders with
@return Attempt Contains no feedback if successful, otherwise the error message]]></Description>
					<X>770</X><Y>110</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[codeFmt]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[args]]></Name>
						<Type><![CDATA[Object...]]></Type>
					</Parameter>
					<Body><![CDATA[String code = String.format(codeFmt, args);
return run(code);]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[T]]></ReturnType>
					<Id>1608074973466</Id>
					<Name><![CDATA[runResults]]></Name>
					<Description><![CDATA[Evaluate an expression ("get value" / expecting a return)<br>
@param returnType The Java class of the return type<br>
@param codeFmt The single line of code to be executed with String-formatted placeholders<br>
@param args The objects to replace the placeholders with<br>
@return T The output, in the type specified]]></Description>
					<CustomModifierCode><![CDATA[public <T>]]></CustomModifierCode>                 	
					<X>770</X><Y>250</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[returnType]]></Name>
						<Type><![CDATA[Class<T>]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[codeFmt]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[args]]></Name>
						<Type><![CDATA[Object...]]></Type>
					</Parameter>
					<Body><![CDATA[String code = String.format(codeFmt, args);
return runResults(returnType, code);]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[Attempt]]></ReturnType>
					<Id>1608075058127</Id>
					<Name><![CDATA[runResults]]></Name>
					<Description><![CDATA[Evaluate an expression ("get value" / expecting a return)<br>
@param codeFmt The single line of code to be executed with String-formatted placeholders<br>
@param args The objects to replace the placeholders with<br>
@return T The output, in the type specified]]></Description>
					<X>770</X><Y>190</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[codeFmt]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[args]]></Name>
						<Type><![CDATA[Object...]]></Type>
					</Parameter>
					<Body><![CDATA[String code = String.format(codeFmt, args);
return runResults(code);]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[Properties]]></ReturnType>
					<Id>1619466563845</Id>
					<Name><![CDATA[getSavedProperties]]></Name>
					<Description><![CDATA[Tries to import the properties file and load it into the model's parameters; if the properties file does not exist, the `generateProperties` function is called.<br>
The default properties file is named "pypeline.properties" and is located next to the Pypeline jar file.]]></Description>
					<X>550</X><Y>210</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[String filename = PROPERTIES_FILENAME;
// First check if one exists in current directory.
// If not, set to the default location.
File f = new File(filename);
if (!f.exists())
	filename = getDefaultPropertiesPath();

// Check if properties exists.
// If not, then there are no saved properties.
f = new File(filename);
if (!f.exists())
	return null;

Properties prop = null;
try (InputStream input = new FileInputStream(filename)) {
	prop = new Properties();
	prop.load(input);
} catch (IOException e) {
	error(e, "Exception when reading properties file");
}
return prop;]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[FutureAttempt]]></ReturnType>
					<Id>1685472571576</Id>
					<Name><![CDATA[runFileHeadless]]></Name>
					<Description><![CDATA[Execute a Python file in the background (headlessly).<br>
@param preferredVersion One of the options for which Python version to run the file<br>
@param args The file path and any arguments to run (flags and values should be separate strings)<br>
@return FutureAttempt A `Future` implementation that will have a partial or completed Attempt object with syserr and sysout content.]]></Description>
					<X>850</X><Y>290</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[preferredVersion]]></Name>
						<Type><![CDATA[PythonCommandType]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[args]]></Name>
						<Type><![CDATA[Object...]]></Type>
					</Parameter>
					<Body><![CDATA[ProcessBuilder pb = buildRunFileProcess(preferredVersion, args);
Process proc;

try {
	proc = pb.start();
} catch (IOException | NullPointerException e) {
	String msg = String.format("Exception with running the command: `%s`\nStack trace is as follows:\n%s",
		String.join(" ", pb.command()),
		ExceptionUtils.toStringStackTrace(e));
	return new FutureAttempt(new Attempt(Attempt.RESULT_ERROR, msg));
}

FutureAttempt future = new FutureAttempt(proc);
headlessAttempts.add(future);
return future;]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[FutureAttempt]]></ReturnType>
					<Id>1685472571578</Id>
					<Name><![CDATA[runFileHeadless]]></Name>
					<Description><![CDATA[Execute a Python file in the background (headlessly).<br>
@param args The file path, and any arguments to run (flags and values should be separate strings)<br>
@return FutureAttempt A `Future` implementation that will have a partial or completed Attempt object with syserr and sysout content.]]></Description>
					<X>870</X><Y>310</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[args]]></Name>
						<Type><![CDATA[Object...]]></Type>
					</Parameter>
					<Body><![CDATA[Object[] tmp = new Object[args.length+1];
tmp[0] = py.activePyPath;
System.arraycopy(args, 0, tmp, 1, args.length);

FutureAttempt future = PyCommunicator.runFileHeadless(PythonCommandType.PYTHON_PATH, tmp);
history.add(0, new Pair<String,Attempt>(Arrays.toString(tmp), future.get())); // even if it won't have the content yet, still include it for the call
validateHistoryLimit();
return future;]]></Body>
				</Function>
				<Function AccessType="private" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[ProcessBuilder]]></ReturnType>
					<Id>1691605534583</Id>
					<Name><![CDATA[buildRunFileProcess]]></Name>
					<Description><![CDATA[Constructs a ProcessBuilder for running a Python script with the specified command type and arguments.]]></Description>
					<X>850</X><Y>350</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[preferredVersion]]></Name>
						<Type><![CDATA[PythonCommandType]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[args]]></Name>
						<Type><![CDATA[Object...]]></Type>
					</Parameter>
					<Body><![CDATA[try {
	String pyCmd = PySubProcess.convertToCommand(preferredVersion);
	if (preferredVersion.equals(PythonCommandType.PYTHON_OTHER)) {
		// replace the desired command arg with the path
		pyCmd = args[0].toString();
		args[0] = PySubProcess.findPythonPath(pyCmd);
	} else if (!preferredVersion.equals(PythonCommandType.PYTHON_PATH)) {
		// add path to python path to the args
		String pyPath = PySubProcess.findPythonPath(pyCmd);
		Object[] tmp = new Object[args.length + 1];
		tmp[0] = pyPath;
		System.arraycopy(args, 0, tmp, 1, args.length);
		args = tmp;
	}
} catch (PyException e) {
	throw new RuntimeException(String.format("Could not find Python path with version %s, args %s", preferredVersion, Arrays.toString(args)));
}

String[] strArgs = Arrays.stream(args).map(a -> a.toString()).toArray(String[]::new);
ProcessBuilder pb = new ProcessBuilder(strArgs);
return pb;]]></Body>
				</Function>
			</Functions>
			<AgentLinks>
				<AgentLink>
					<Id>1569858524850</Id>
					<Name><![CDATA[connections]]></Name>
					<ExcludeFromBuild>true</ExcludeFromBuild>
					<X>50</X><Y>-50</Y>
					<Label><X>15</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<HandleReceiveInConnections>false</HandleReceiveInConnections>
					<AgentLinkType>COLLECTION_OF_LINKS</AgentLinkType>
					<AgentLinkBidirectional>true</AgentLinkBidirectional>
					<MessageType><![CDATA[Object]]></MessageType>
					<LineStyle>SOLID</LineStyle>
					<LineWidth>1</LineWidth>
					<LineColor>-16777216</LineColor>
					<LineZOrder>UNDER_AGENTS</LineZOrder>
					<LineArrow>NONE</LineArrow>
					<LineArrowPosition>END</LineArrowPosition>
				</AgentLink>
			</AgentLinks>


			<Presentation>
				<Level>
					<Id>1569858524854</Id>
					<Name><![CDATA[level]]></Name>
					<X>0</X><Y>0</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<Z>0</Z>
					<LevelVisibility>DIM_NON_CURRENT</LevelVisibility>

			<Presentation>
				<Image>
					<Id>1582833534630</Id>
					<Name><![CDATA[image2]]></Name>
					<X>5</X><Y>5</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<OnClickCode><![CDATA[return true;]]></OnClickCode>
					<EmbeddedIcon>true</EmbeddedIcon>
					<Z>0</Z>
					<Width>32</Width>
					<Height>32</Height>
					<Rotation>0.0</Rotation>
					<ImageFiles>
						<ImageResourceReference>
							<PackageName><![CDATA[com.anylogic.libraries.pypeline]]></PackageName>
							<ClassName><![CDATA[Python-logo.png]]></ClassName>
						</ImageResourceReference>
					</ImageFiles>
					<OriginalSize>true</OriginalSize>
				</Image>
				<Text>
					<Id>1684259104128</Id>
					<Name><![CDATA[text]]></Name>
					<X>40</X><Y>570</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>false</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-8355712</Color>
					<Text><![CDATA[GRAYED OBJECTS ARE INHERITED FROM THE JSONIFIER LIBRARY]]></Text>
					<Font>
						<Name>SansSerif</Name>
						<Size>16</Size>
						<Style>2</Style>
					</Font>
					<Alignment>LEFT</Alignment>
				</Text>
			</Presentation>

				</Level>
			</Presentation>

		</ActiveObjectClass>
		<!--   =========   Active Object Class   ========  -->
		<ActiveObjectClass>
			<Id>1665787765899</Id>
			<Name><![CDATA[Jsonifier]]></Name>
			<Description><![CDATA[Add this custom object to your model to gain access to all the functions for serializing and deserializing objects in your model. For serialization of agents and populations (via the `toJson` functions), you can customize the filter, which defines what fields are/are not included, through the properties of the object. 
Note that the filter is shared by all instances of the Jsonfiier object, so you only need one instance per model.]]></Description>
			<AdditionalClassCode><![CDATA[{
// initialize the filter here to allow for functionality when this obj is created without a constructor / as a POJO;
// this will get overridden if being created as an agent.
jsonFilter = new JsonFilter(objmapper, true);

// assign static reference to the top level agent for global access to various functions
root = getRootAgent();
}

/**
* Initialize the class when called within an AL scope (e.g., as a variable object).
* Using this parameter enables the ability to parse string to value when converting JSON to agent(s); without it, an exception will be thrown if the type does not match.
* @param anyAgent An agent that is already registered with the AL Engine; can be the Java keyword 'this' if calling this constructor from an agent.
*/
public Jsonifier(Agent anyAgent) {
	this.createAndStart(anyAgent);
}

/**
* Initialize the class in the specified mode with either empty or default inclusion configuration.
* Note that if empty, a blacklisted filter will allow everything through and a whitelisted filter will allow nothing.
* @param isBlacklistMode Whether the filters' references should be blocked from the output (blacklist/true) or should be the only references allowed (whitelist/false)
* @param loadDefaultConfig Whether to load the default references for the provided mode or have the filter completely empty
*/
public Jsonifier(boolean isBlacklistMode, boolean loadDefaultConfig) {
	// lazily set all inclusions as default even if using empty (will be ignored though)
	this(isBlacklistMode, loadDefaultConfig, 
		JsonFilter.defaultBlacklistAutogeneratedSetting, JsonFilter.defaultWhitelistAutogeneratedSetting, 
		JsonFilter.defaultBlacklistedPackages.toArray(String[]::new), JsonFilter.defaultWhitelistedPackages.toArray(String[]::new), 
		JsonFilter.defaultBlacklistedClasses.toArray(Class<?>[]::new), JsonFilter.defaultWhitelistedClasses.toArray(Class<?>[]::new), 
		JsonFilter.defaultBlacklistedNames.toArray(String[]::new), JsonFilter.defaultWhitelistedNames.toArray(String[]::new));
}

/**
* Initialize the class in the specified mode with either empty or default inclusion configuration.
* Note that if empty, a blacklisted filter will allow everything through and a whitelisted filter will allow nothing.
* This variant includes an agent to enable the ability to parse string to value when converting JSON to agent(s); without it, an exception will be thrown if the type does not match.
* @param anyAgent An agent that is already registered with the AL Engine; can be the Java keyword 'this' if calling this constructor from an agent.
* @param isBlacklistMode Whether the filters' references should be blocked from the output (blacklist/true) or should be the only references allowed (whitelist/false)
* @param loadDefaultConfig Whether to load the default references for the provided mode or have the filter completely empty
*/
public Jsonifier(Agent anyAgent, boolean isBlacklistMode, boolean loadDefaultConfig) {
	// lazily set all inclusions as default even if using empty (will be ignored though)
	this(isBlacklistMode, loadDefaultConfig, 
		JsonFilter.defaultBlacklistAutogeneratedSetting, JsonFilter.defaultWhitelistAutogeneratedSetting, 
		JsonFilter.defaultBlacklistedPackages.toArray(String[]::new), JsonFilter.defaultWhitelistedPackages.toArray(String[]::new), 
		JsonFilter.defaultBlacklistedClasses.toArray(Class<?>[]::new), JsonFilter.defaultWhitelistedClasses.toArray(Class<?>[]::new), 
		JsonFilter.defaultBlacklistedNames.toArray(String[]::new), JsonFilter.defaultWhitelistedNames.toArray(String[]::new));
	this.createAndStart(anyAgent);
}

/**
* Initialize the class in the specified mode with the specified inclusions.
* @param isBlacklistMode Whether the filters' references should be blocked from the output (blacklist/true) or should be the only references allowed (whitelist/false)
* @param includeAutogenerateds Whether to include autogenerated variables/functions in the filter
* @param includedPackages The package names for which any classes in them should be considered in the filter
* @param includedClasses The classes to be included in the filter
* @param includedNames The object names or regex patterns for which any matches will be considered in the filter
*/ 
public Jsonifier(boolean isBlacklistMode, boolean includeAutogenerateds, String[] includedPackages, Class<?>[] includedClasses, String[] includedNames) {
	// lazily set the same value for both BL and WL variants
	this(isBlacklistMode, true, 
		includeAutogenerateds, includeAutogenerateds, 
		includedPackages, includedPackages, 
		includedClasses, includedClasses, 
		includedNames, includedNames);
}

/**
* Initialize the class in the specified mode with the specified inclusions.
* This variant includes an agent to enable the ability to parse string to value when converting JSON to agent(s); without it, an exception will be thrown if the type does not match.
* @param anyAgent An agent that is already registered with the AL Engine; can be the Java keyword 'this' if calling this constructor from an agent.
* @param isBlacklistMode Whether the filters' references should be blocked from the output (blacklist/true) or should be the only references allowed (whitelist/false)
* @param includeAutogenerateds Whether to include autogenerated variables/functions in the filter
* @param includedPackages The package names for which any classes in them should be considered in the filter
* @param includedClasses The classes to be included in the filter
* @param includedNames The object names or regex patterns for which any matches will be considered in the filter
*/ 
public Jsonifier(Agent anyAgent, boolean isBlacklistMode, boolean includeAutogenerateds, String[] includedPackages, Class<?>[] includedClasses, String[] includedNames) {
	// lazily set the same value for both BL and WL variants
	this(isBlacklistMode, true, 
		includeAutogenerateds, includeAutogenerateds, 
		includedPackages, includedPackages, 
		includedClasses, includedClasses, 
		includedNames, includedNames);
	this.createAndStart(anyAgent);
}

private enum ObjectAgentType {
	JAVA, // pure java type
	AGENT_SINGLE, // single agent
	AGENT_POPULATION, // anylogic-population (of agents)
	AGENT_COLLECTION // java collection with agent-typed components
}]]></AdditionalClassCode>
			<Import><![CDATA[import java.io.IOException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.JsonNode;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Modifier;
import java.util.stream.IntStream;
import java.lang.reflect.Field;
import com.fasterxml.jackson.databind.SerializationFeature;
import java.io.FileWriter;
import java.io.FileNotFoundException;
import java.io.File;
import java.util.Scanner;
import java.io.FileReader;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.nio.file.InvalidPathException;
import com.fasterxml.jackson.databind.module.SimpleModule;
import java.lang.reflect.Type;
import java.util.stream.Collectors;
import com.anylogic.engine.AnyLogicCustomSerialization;
import com.fasterxml.jackson.databind.MapperFeature;
import com.fasterxml.jackson.databind.JsonSerializer;
import com.fasterxml.jackson.databind.ser.std.StdSerializer;
import java.net.URL;
import com.fasterxml.jackson.databind.node.ArrayNode;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.exc.InvalidFormatException;]]></Import>
			<StartupCode><![CDATA[// Initialize the filter based on the parameter values
if (!isCustomConfiguration) { 
	// start empty with default autogenerated setting
	jsonFilter = new JsonFilter(objmapper, isBlacklistMode, 
						isBlacklistMode ? JsonFilter.defaultBlacklistAutogeneratedSetting : JsonFilter.defaultWhitelistAutogeneratedSetting, 
						null, null, null);
} else if (isBlacklistMode) {
	// use the BL params
	jsonFilter = new JsonFilter(
						objmapper, isBlacklistMode, 
						includeAutogeneratedsBL,
						includedPackagesBL,
						includedClassesBL,
						includedNamesBL
	);
} else {
	// use the WL params
	jsonFilter = new JsonFilter(
						objmapper, isBlacklistMode, 
						includeAutogeneratedsWL,
						includedPackagesWL,
						includedClassesWL,
						includedNamesWL
	);
}

// This next step is purely for library validation purposes across future updates.
// It confirms the "Default value" used by the parameters match the constants defined in the JsonFilter class.
// Setting it up this way lets users see which objects are included by default 
//		w/o needing to waste runs for printing the queried defaults or needing to reference the docs.
if (_includeAutogeneratedsBL_DefaultValue_xjal() != JsonFilter.defaultBlacklistAutogeneratedSetting)
	warning("Parameter for blacklisted autogenerated setting is not synced properly; library needs to be fixed");
	
if (_includeAutogeneratedsWL_DefaultValue_xjal() != JsonFilter.defaultWhitelistAutogeneratedSetting)
	warning("Parameter for whitelisted autogenerated setting is not synced properly; library needs to be fixed");

if (!Set.of(_includedPackagesBL_DefaultValue_xjal()).equals(JsonFilter.defaultBlacklistedPackages))
	warning("Parameter for blacklisted packages are not synced properly; library needs to be fixed");

if (!Set.of(_includedPackagesWL_DefaultValue_xjal()).equals(JsonFilter.defaultWhitelistedPackages))
	warning("Parameter for whitelisted packages are not synced properly; library needs to be fixed");

if (!Set.of(_includedClassesBL_DefaultValue_xjal()).equals(JsonFilter.defaultBlacklistedClasses))
	warning("Parameter for blacklisted classes are not synced properly; library needs to be fixed");

if (!Set.of(_includedClassesWL_DefaultValue_xjal()).equals(JsonFilter.defaultWhitelistedClasses))
	warning("Parameter for whitelisted classes are not synced properly; library needs to be fixed");

if (!Set.of(_includedNamesBL_DefaultValue_xjal()).equals(JsonFilter.defaultBlacklistedNames))
	warning("Parameter for blacklisted names are not synced properly; library needs to be fixed");

if (!Set.of(_includedNamesWL_DefaultValue_xjal()).equals(JsonFilter.defaultWhitelistedNames))
	warning("Parameter for whitelisted names are not synced properly; library needs to be fixed");
]]></StartupCode>
			<Generic>false</Generic>
			<GenericParameter>
				<Id>1665787765897</Id>
				<Name><![CDATA[1665787765897]]></Name>
				<GenericParameterValue Class="CodeValue">
					<Code><![CDATA[T extends Agent]]></Code>
				</GenericParameterValue>
				<GenericParameterLabel><![CDATA[Generic parameter:]]></GenericParameterLabel>
			</GenericParameter>
			<FlowchartBlock>true</FlowchartBlock>
			<FlowChartsUsage>ENTITY</FlowChartsUsage>
			<SamplesToKeep>100</SamplesToKeep>
			<LimitNumberOfArrayElements>false</LimitNumberOfArrayElements>
			<ElementsLimitValue>100</ElementsLimitValue>
			<MakeDefaultViewArea>false</MakeDefaultViewArea>
			<SceneGridColor/>
			<SceneBackgroundColor/>
			<SceneSkybox>null</SceneSkybox>
			<AgentProperties>
				<EnvironmentDefinesInitialLocation>true</EnvironmentDefinesInitialLocation>
				<RotateAnimationTowardsMovement>true</RotateAnimationTowardsMovement>
				<RotateAnimationVertically>false</RotateAnimationVertically>
				<VelocityCode Class="CodeUnitValue">
					<Code><![CDATA[10]]></Code>
					<Unit Class="SpeedUnits"><![CDATA[MPS]]></Unit>
				</VelocityCode>
				<PhysicalLength Class="CodeUnitValue">
					<Code><![CDATA[1]]></Code>
					<Unit Class="LengthUnits"><![CDATA[METER]]></Unit>
				</PhysicalLength>
				<PhysicalWidth Class="CodeUnitValue">
					<Code><![CDATA[1]]></Code>
					<Unit Class="LengthUnits"><![CDATA[METER]]></Unit>
				</PhysicalWidth>
				<PhysicalHeight Class="CodeUnitValue">
					<Code><![CDATA[1]]></Code>
					<Unit Class="LengthUnits"><![CDATA[METER]]></Unit>
				</PhysicalHeight>
			</AgentProperties>
			<EnvironmentProperties>
					<EnableSteps>false</EnableSteps>
					<StepDurationCode Class="CodeUnitValue">
						<Code><![CDATA[1.0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[SECOND]]></Unit>
					</StepDurationCode>
					<SpaceType>CONTINUOUS</SpaceType>
					<WidthCode><![CDATA[500]]></WidthCode>
					<HeightCode><![CDATA[500]]></HeightCode>
					<ZHeightCode><![CDATA[0]]></ZHeightCode>
					<ColumnsCountCode><![CDATA[100]]></ColumnsCountCode>
					<RowsCountCode><![CDATA[100]]></RowsCountCode>
					<NeigborhoodType>MOORE</NeigborhoodType>
					<LayoutType>USER_DEF</LayoutType>
					<LayoutTypeApplyOnStartup>true</LayoutTypeApplyOnStartup>
					<NetworkType>USER_DEF</NetworkType>
					<NetworkTypeApplyOnStartup>true</NetworkTypeApplyOnStartup>
					<ConnectionsPerAgentCode><![CDATA[2]]></ConnectionsPerAgentCode>
					<ConnectionsRangeCode><![CDATA[50]]></ConnectionsRangeCode>
					<NeighborLinkFractionCode><![CDATA[0.95]]></NeighborLinkFractionCode>
					<MCode><![CDATA[10]]></MCode>
			</EnvironmentProperties>
			<DatasetsCreationProperties>
				<AutoCreate>false</AutoCreate>
					<OccurrenceAtTime>true</OccurrenceAtTime>
					<OccurrenceDate>1665820800000</OccurrenceDate>
					<OccurrenceTime Class="CodeUnitValue">
						<Code><![CDATA[0]]></Code>
						<Unit Class="TimeUnits"><![CDATA[SECOND]]></Unit>
					</OccurrenceTime>
					<RecurrenceCode Class="CodeUnitValue">
						<Code><![CDATA[1]]></Code>
						<Unit Class="TimeUnits"><![CDATA[SECOND]]></Unit>
					</RecurrenceCode>
			</DatasetsCreationProperties>
			<ScaleRuler>
				<Id>1665787765895</Id>
				<Name><![CDATA[scale]]></Name>
				<X>0</X><Y>-150</Y>
				<PublicFlag>false</PublicFlag>
				<PresentationFlag>false</PresentationFlag>
				<ShowLabel>false</ShowLabel>
				<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
				<Length>100</Length>
				<Rotation>0</Rotation>
				<ScaleType>BASED_ON_LENGTH</ScaleType>
				<ModelLength>10</ModelLength>
				<LengthUnits>METER</LengthUnits>
				<Scale>10</Scale>
				<InheritedFromParentAgentType>true</InheritedFromParentAgentType>
			</ScaleRuler>
			<CurrentLevel>1665787765898</CurrentLevel>
			<ConnectionsId>1665787765894</ConnectionsId>
			<Variables>
				<Variable Class="PlainVariable">
					<Id>1665787820200</Id>
					<Name><![CDATA[objmapper]]></Name>
					<Description><![CDATA[An instance of Jackson's <code>ObjectMapper</code> class; used in the <code>toJson</code> and <code>fromJson</code> functions.]]></Description>
					<X>60</X><Y>70</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="true">
						<Type><![CDATA[ObjectMapper]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[createMapper()]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1665787820202</Id>
					<Name><![CDATA[jsonFilter]]></Name>
					<X>60</X><Y>110</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="public" StaticVariable="true">
						<Type><![CDATA[JsonFilter]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[// initialized in addtl class code]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="PlainVariable">
					<Id>1684182821126</Id>
					<Name><![CDATA[root]]></Name>
					<Description><![CDATA[A static reference to the top-level agent.
It's only assigned when this object is created in an AL environment. It's used to enable code present in JSON to be evaluated (e.g., if a boolean parameter's value is given as <code>randomTrue(0.25)</code>).]]></Description>
					<X>60</X><Y>130</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" Constant="false" AccessType="protected" StaticVariable="true">
						<Type><![CDATA[Agent]]></Type>        
						<InitialValue Class="CodeValue">
							<Code><![CDATA[// static reference to top level agent
// (only assigned when this object is created in an AL env)]]></Code>
						</InitialValue>
					</Properties>
				</Variable>
				<Variable Class="Parameter">
					<Id>1682441114532</Id>
					<Name><![CDATA[isBlacklistMode]]></Name>
					<Description><![CDATA[Whether the filter is in blacklist mode (included objects are omitted from the output) or whitelist mode (only included objects will be in the output).
Calling this parameter's `set_` function will apply the mode and then reset based on the included objects in the other parameters.]]></Description>
					<X>-250</X><Y>70</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[boolean]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<SdArray>false</SdArray>
						<DefaultValue Class="CodeValue">
							<Code><![CDATA[true]]></Code>
						</DefaultValue>
						<OnChangeCode><![CDATA[jsonFilter.setMode(isBlacklistMode, false)
			.setAutogenerated(isBlacklistMode ? includeAutogeneratedsBL : includeAutogeneratedsWL)
			.includePackages(isBlacklistMode ? includedPackagesBL : includedPackagesWL)
			.includeClasses(isBlacklistMode ? includedClassesBL : includedClassesWL)
			.includeNames(isBlacklistMode ? includedNamesBL : includedNamesWL);]]></OnChangeCode>
						<ParameterEditor>
							<Id>1682441114530</Id>
							<Label><![CDATA[Filter mode]]></Label>
							<EditorContolType>RADIO_BUTTONS</EditorContolType>
							<PredefParamValue>
								<Id>0</Id>
								<Name><![CDATA[Blacklist]]></Name>
								<Value Class="CodeValue">
									<Code><![CDATA[true]]></Code>
								</Value>
							</PredefParamValue>
							<PredefParamValue>
								<Id>0</Id>
								<Name><![CDATA[Whitelist]]></Name>
								<Value Class="CodeValue">
									<Code><![CDATA[false]]></Code>
								</Value>
							</PredefParamValue>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>SEPARATE_SECTION</DelimeterType>
							<StartSection><![CDATA[To-JSON Settings]]></StartSection>
						</ParameterEditor>
					</Properties>                 
				</Variable>
				<Variable Class="Parameter">
					<Id>1682441170868</Id>
					<Name><![CDATA[isCustomConfiguration]]></Name>
					<Description><![CDATA[Whether to start the filter with empty inclusions or filled with the sets of objects. If empty, being in blacklist mode will try to output everything, while being in whitelist mode will block everything.
Calling this function's `set_` function and with the custom option enabled (i.e., `true`) will use the values of the parameters; if the empty option is enabled (i.e., `false`) the autogenerated flag will use the blacklist's parameter value and the sets will be cleared.]]></Description>
					<X>-250</X><Y>100</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[boolean]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<SdArray>false</SdArray>
						<DefaultValue Class="CodeValue">
							<Code><![CDATA[true]]></Code>
						</DefaultValue>
						<OnChangeCode><![CDATA[if (isCustomConfiguration) {
	jsonFilter
			.setAutogenerated(isBlacklistMode ? includeAutogeneratedsBL : includeAutogeneratedsWL)
			.includePackages(isBlacklistMode ? includedPackagesBL : includedPackagesWL)
			.includeClasses(isBlacklistMode ? includedClassesBL : includedClassesWL)
			.includeNames(isBlacklistMode ? includedNamesBL : includedNamesWL);
} else {
	jsonFilter
			.setAutogenerated(isBlacklistMode ? includeAutogeneratedsBL : includeAutogeneratedsWL)
			.clearPackages()
			.clearClasses()
			.clearNames();
}]]></OnChangeCode>
						<ParameterEditor>
							<Id>1682441170866</Id>
							<Label><![CDATA[Initial configuration]]></Label>
							<EditorContolType>RADIO_BUTTONS</EditorContolType>
							<PredefParamValue>
								<Id>1682441170865</Id>
								<Name><![CDATA[Empty]]></Name>
								<Value Class="CodeValue">
									<Code><![CDATA[false]]></Code>
								</Value>
							</PredefParamValue>
							<PredefParamValue>
								<Id>1682441170864</Id>
								<Name><![CDATA[Custom]]></Name>
								<Value Class="CodeValue">
									<Code><![CDATA[true]]></Code>
								</Value>
							</PredefParamValue>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
				<Variable Class="Parameter">
					<Id>1682441255593</Id>
					<Name><![CDATA[includeAutogeneratedsBL]]></Name>
					<Description><![CDATA[Whether the autogenerated objects will be initially included in the blacklist (i.e., omitted from any JSON outputs).
Calling this function's `set_` function will update the filter, or you can use the function inside the filter object. 
An error will be thrown if trying to set this while in whitelist mode (use the other parameter).]]></Description>
					<X>-250</X><Y>130</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[boolean]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<SdArray>false</SdArray>
						<DefaultValue Class="CodeValue">
							<Code><![CDATA[true]]></Code>
						</DefaultValue>
						<OnChangeCode><![CDATA[if (!isBlacklistMode)
	error("Cannot update the filter in whitelist mode with a blacklist parameter.");
jsonFilter.setAutogenerated(includeAutogeneratedsBL);]]></OnChangeCode>
						<ParameterEditor>
							<Id>1682441255591</Id>
							<Label><![CDATA[Block autogenerated objects]]></Label>
							<EditorContolType>CHECK_BOX</EditorContolType>
							<HideCondition>
								<Id>0</Id>
								<ParameterId>1682441170868</ParameterId>
								<Operation>EQUALS</Operation>
								<Value Class="CodeValue">
									<Code><![CDATA[false]]></Code>
								</Value>
							</HideCondition>
							<HideCondition>
								<Id>0</Id>
								<ParameterId>1682441114532</ParameterId>
								<Operation>EQUALS</Operation>
								<Value Class="CodeValue">
									<Code><![CDATA[false]]></Code>
								</Value>
							</HideCondition>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
				<Variable Class="Parameter">
					<Id>1682441621807</Id>
					<Name><![CDATA[includeAutogeneratedsWL]]></Name>
					<Description><![CDATA[Whether the autogenerated objects will be initially included in the whitelist (i.e., included in  any JSON outputs).
Calling this function's `set_` function will update the filter, or you can use the function inside the filter object. 
An error will be thrown if trying to set this while in blacklist mode (use the other parameter).]]></Description>
					<X>-250</X><Y>150</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[boolean]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<SdArray>false</SdArray>
						<DefaultValue Class="CodeValue">
							<Code><![CDATA[false]]></Code>
						</DefaultValue>
						<OnChangeCode><![CDATA[if (isBlacklistMode)
	error("Cannot update the filter in blacklist mode with a whitelist parameter.");
jsonFilter.setAutogenerated(includeAutogeneratedsWL);]]></OnChangeCode>
						<ParameterEditor>
							<Id>1682441621805</Id>
							<Label><![CDATA[Allow autogenerated objects]]></Label>
							<EditorContolType>CHECK_BOX</EditorContolType>
							<HideCondition>
								<Id>0</Id>
								<ParameterId>1682441170868</ParameterId>
								<Operation>EQUALS</Operation>
								<Value Class="CodeValue">
									<Code><![CDATA[false]]></Code>
								</Value>
							</HideCondition>
							<HideCondition>
								<Id>1682441621804</Id>
								<ParameterId>1682441114532</ParameterId>
								<Operation>EQUALS</Operation>
								<Value Class="CodeValue">
									<Code><![CDATA[true]]></Code>
								</Value>
							</HideCondition>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
				<Variable Class="Parameter">
					<Id>1682441417778</Id>
					<Name><![CDATA[includedPackagesBL]]></Name>
					<Description><![CDATA[The initial set of package names, for which any classes belonging to these will be blocked from being outputted to JSON. 
Calling this function's `set_` function will update the filter with the new set. Individual objects can be added/removed using the functions in the filter object.
An error will be thrown if trying to set this while in whitelist mode (use the other parameter).]]></Description>
					<X>-250</X><Y>230</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[String[]]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<SdArray>false</SdArray>
						<DefaultValue Class="CodeValue">
							<Code><![CDATA[new String[] {
	"com.anylogic.libraries.pypeline",
	"anylogic_jsonifier_library",
	"com.anylogic.libraries.processmodeling",
	"com.anylogic.libraries.material_handling",
	"com.anylogic.libraries.pedestrian",
	"com.anylogic.libraries.rail",
	"com.anylogic.libraries.road",
	"com.anylogic.libraries.fluid",
	"com.anylogic.engine.markup",
	"com.anylogic.engine.connectivity",
	"com.anylogic.engine.presentation"
}]]></Code>
						</DefaultValue>
						<OnChangeCode><![CDATA[if (!isBlacklistMode)
	error("Cannot update the filter in whitelist mode with a blacklist parameter.");
jsonFilter.clearPackages().includePackages(includedPackagesBL);]]></OnChangeCode>
						<ParameterEditor>
							<Id>1682441417776</Id>
							<Label><![CDATA[Blocked packages]]></Label>
							<EditorContolType>ONE_DIMENSIONAL_ARRAY</EditorContolType>
							<HideCondition>
								<Id>0</Id>
								<ParameterId>1682441170868</ParameterId>
								<Operation>EQUALS</Operation>
								<Value Class="CodeValue">
									<Code><![CDATA[false]]></Code>
								</Value>
							</HideCondition>
							<HideCondition>
								<Id>0</Id>
								<ParameterId>1682441114532</ParameterId>
								<Operation>EQUALS</Operation>
								<Value Class="CodeValue">
									<Code><![CDATA[false]]></Code>
								</Value>
							</HideCondition>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
				<Variable Class="Parameter">
					<Id>1682441478227</Id>
					<Name><![CDATA[includedPackagesWL]]></Name>
					<Description><![CDATA[The initial set of package names, for which any classes belonging to these will be allowed to be outputted to JSON. 
Calling this function's `set_` function will update the filter with the new set. Individual objects can be added/removed using the functions in the filter object.
An error will be thrown if trying to set this while in blacklist mode (use the other parameter).]]></Description>
					<X>-250</X><Y>250</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[String[]]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<SdArray>false</SdArray>
						<DefaultValue Class="CodeValue">
							<Code><![CDATA[new String[] {
	"java.util",
	"java.lang"
}]]></Code>
						</DefaultValue>
						<OnChangeCode><![CDATA[if (isBlacklistMode)
	error("Cannot update the filter in blacklist mode with a whitelist parameter.");
jsonFilter.clearPackages().includePackages(includedPackagesWL);]]></OnChangeCode>
						<ParameterEditor>
							<Id>1682441478225</Id>
							<Label><![CDATA[Allowed packages]]></Label>
							<EditorContolType>ONE_DIMENSIONAL_ARRAY</EditorContolType>
							<HideCondition>
								<Id>0</Id>
								<ParameterId>1682441170868</ParameterId>
								<Operation>EQUALS</Operation>
								<Value Class="CodeValue">
									<Code><![CDATA[false]]></Code>
								</Value>
							</HideCondition>
							<HideCondition>
								<Id>0</Id>
								<ParameterId>1682441114532</ParameterId>
								<Operation>EQUALS</Operation>
								<Value Class="CodeValue">
									<Code><![CDATA[true]]></Code>
								</Value>
							</HideCondition>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
				<Variable Class="Parameter">
					<Id>1682441320254</Id>
					<Name><![CDATA[includedClassesBL]]></Name>
					<Description><![CDATA[The set of classes initially blocked being outputted to JSON. 
Calling this function's `set_` function will update the filter. An error will be thrown if trying to set this while in whitelist mode (use the other parameter).]]></Description>
					<X>-250</X><Y>180</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[Class<?>[]]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<SdArray>false</SdArray>
						<DefaultValue Class="CodeValue">
							<Code><![CDATA[new Class<?>[] {
	Color.class,
	Font.class,
	Shape.class,
	EventOriginator.class,
	IStatechartState.class,
	AbstractLinkToAgent.class,
	Scale.class,
	CustomDistribution.class,
	Random.class,
	Histogram.Appearance.class,
	Histogram2D.Appearance.class,
	Chart2DPlot.Appearance.class,
	SDIntegrationManager.class,
	LinkToAgentAnimationSettings.class,
	Port.class
}]]></Code>
						</DefaultValue>
						<OnChangeCode><![CDATA[if (!isBlacklistMode)
	error("Cannot update the filter in whitelist mode with a blacklist parameter.");
jsonFilter.clearClasses().includeClasses(includedClassesBL);]]></OnChangeCode>
						<ParameterEditor>
							<Id>1682441320252</Id>
							<Label><![CDATA[Blocked classes]]></Label>
							<EditorContolType>ELEMENT_CHOOSER</EditorContolType>
							<HideCondition>
								<Id>0</Id>
								<ParameterId>1682441170868</ParameterId>
								<Operation>EQUALS</Operation>
								<Value Class="CodeValue">
									<Code><![CDATA[false]]></Code>
								</Value>
							</HideCondition>
							<HideCondition>
								<Id>0</Id>
								<ParameterId>1682441114532</ParameterId>
								<Operation>EQUALS</Operation>
								<Value Class="CodeValue">
									<Code><![CDATA[false]]></Code>
								</Value>
							</HideCondition>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
				<Variable Class="Parameter">
					<Id>1682441393197</Id>
					<Name><![CDATA[includedClassesWL]]></Name>
					<Description><![CDATA[The set of classes allowed to be outputted to JSON.
Calling this function's `set_` function will update the filter. An error will be thrown if trying to set this while in blacklist mode (use the other parameter).]]></Description>
					<X>-250</X><Y>200</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[Class<?>[]]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<SdArray>false</SdArray>
						<DefaultValue Class="CodeValue">
							<Code><![CDATA[new Class<?>[] {
	Number.class,
	Boolean.class,
	Agent.class,
	AgentList.class,
	ChartItem.class,
	DataItem.class,
	DataSet.class,
	HistogramData.class,
	StatisticsContinuous.class,
	StatisticsDiscrete.class
}	]]></Code>
						</DefaultValue>
						<OnChangeCode><![CDATA[if (isBlacklistMode)
	error("Cannot update the filter in blacklist mode with a whitelist parameter.");
jsonFilter.clearClasses().includeClasses(includedClassesWL);]]></OnChangeCode>
						<ParameterEditor>
							<Id>1682441393195</Id>
							<Label><![CDATA[Allowed classes]]></Label>
							<EditorContolType>ONE_DIMENSIONAL_ARRAY</EditorContolType>
							<HideCondition>
								<Id>0</Id>
								<ParameterId>1682441170868</ParameterId>
								<Operation>EQUALS</Operation>
								<Value Class="CodeValue">
									<Code><![CDATA[false]]></Code>
								</Value>
							</HideCondition>
							<HideCondition>
								<Id>0</Id>
								<ParameterId>1682441114532</ParameterId>
								<Operation>EQUALS</Operation>
								<Value Class="CodeValue">
									<Code><![CDATA[true]]></Code>
								</Value>
							</HideCondition>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
				<Variable Class="Parameter">
					<Id>1682441493523</Id>
					<Name><![CDATA[includedNamesBL]]></Name>
					<Description><![CDATA[The initial set of object names, or regex patterns, for which any object whose name matches any one of these will be blocked from being outputted to JSON. 
Calling this function's `set_` function will update the filter with the new set. Individual objects can be added/removed using the functions in the filter object.
An error will be thrown if trying to set this while in whitelist mode (use the other parameter).]]></Description>
					<X>-250</X><Y>280</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[String[]]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<SdArray>false</SdArray>
						<DefaultValue Class="CodeValue">
							<Code><![CDATA[new String[] {
	".+_xjal",
	"serialVersionUID"
}]]></Code>
						</DefaultValue>
						<OnChangeCode><![CDATA[if (!isBlacklistMode)
	error("Cannot update the filter in whitelist mode with a blacklist parameter.");
jsonFilter.clearNames().includeNames(includedNamesBL);]]></OnChangeCode>
						<ParameterEditor>
							<Id>1682441493521</Id>
							<Label><![CDATA[Blocked names]]></Label>
							<EditorContolType>ONE_DIMENSIONAL_ARRAY</EditorContolType>
							<HideCondition>
								<Id>0</Id>
								<ParameterId>1682441170868</ParameterId>
								<Operation>EQUALS</Operation>
								<Value Class="CodeValue">
									<Code><![CDATA[false]]></Code>
								</Value>
							</HideCondition>
							<HideCondition>
								<Id>0</Id>
								<ParameterId>1682441114532</ParameterId>
								<Operation>EQUALS</Operation>
								<Value Class="CodeValue">
									<Code><![CDATA[false]]></Code>
								</Value>
							</HideCondition>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
				<Variable Class="Parameter">
					<Id>1682441516127</Id>
					<Name><![CDATA[includedNamesWL]]></Name>
					<Description><![CDATA[The initial set of object names, or regex patterns, for which any object whose name matches any one of these will be allowed to be outputted to JSON. 
Calling this function's `set_` function will update the filter with the new set. Individual objects can be added/removed using the functions in the filter object.
An error will be thrown if trying to set this while in blacklist mode (use the other parameter).]]></Description>
					<X>-250</X><Y>300</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" ModificatorType="STATIC">
						<Type><![CDATA[String[]]]></Type>
						<UnitType><![CDATA[NONE]]></UnitType>
						<SdArray>false</SdArray>
						<DefaultValue Class="CodeValue">
							<Code><![CDATA[new String[] {

}]]></Code>
						</DefaultValue>
						<OnChangeCode><![CDATA[if (isBlacklistMode)
	error("Cannot update the filter in blacklist mode with a whitelist parameter.");
jsonFilter.clearNames().includeNames(includedNamesWL);]]></OnChangeCode>
						<ParameterEditor>
							<Id>1682441516125</Id>
							<Label><![CDATA[Allowed names]]></Label>
							<EditorContolType>ONE_DIMENSIONAL_ARRAY</EditorContolType>
							<HideCondition>
								<Id>0</Id>
								<ParameterId>1682441170868</ParameterId>
								<Operation>EQUALS</Operation>
								<Value Class="CodeValue">
									<Code><![CDATA[false]]></Code>
								</Value>
							</HideCondition>
							<HideCondition>
								<Id>0</Id>
								<ParameterId>1682441114532</ParameterId>
								<Operation>EQUALS</Operation>
								<Value Class="CodeValue">
									<Code><![CDATA[true]]></Code>
								</Value>
							</HideCondition>
							<MinSliderValue><![CDATA[0]]></MinSliderValue>
							<MaxSliderValue><![CDATA[100]]></MaxSliderValue>
							<DelimeterType>NO_DELIMETER</DelimeterType>
						</ParameterEditor>
					</Properties>                 
				</Variable>
				<Variable Class="CollectionVariable">
					<Id>1665787820172</Id>
					<Name><![CDATA[warnedParameters]]></Name>
					<X>360</X><Y>480</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" AccessType="public" StaticVariable="true">
						<CollectionClass><![CDATA[LinkedHashSet]]></CollectionClass>
						<ElementClass><![CDATA[String]]></ElementClass>
						<ValueElementClass><![CDATA[String]]></ValueElementClass>
					</Properties>

				</Variable>
				<Variable Class="CollectionVariable">
					<Id>1678491140331</Id>
					<Name><![CDATA[serializedClasses]]></Name>
					<X>210</X><Y>480</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Properties SaveInSnapshot="true" AccessType="private" StaticVariable="true">
						<CollectionClass><![CDATA[ArrayList]]></CollectionClass>
						<ElementClass><![CDATA[Class<?>]]></ElementClass>
						<ValueElementClass><![CDATA[String]]></ValueElementClass>
						<CollectionInitializer Class="CodeValue">
							<Code><![CDATA[Arrays.stream(Serializers.class.getDeclaredClasses())
        .filter(innerClass -> !Modifier.isAbstract(innerClass.getModifiers()))
        .map(innerClass -> {
            ParameterizedType parameterizedType = (ParameterizedType) innerClass.getGenericSuperclass();
            return (Class<?>) parameterizedType.getActualTypeArguments()[0];
        })
        .collect(Collectors.toList())]]></Code>
						</CollectionInitializer>
					</Properties>

				</Variable>
			</Variables>
			<Functions>
				<Function AccessType="public" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[String]]></ReturnType>
					<Id>1665787820174</Id>
					<Name><![CDATA[toJson]]></Name>
					<Description><![CDATA[Converts the given object to JSON.
Note that agents and agent populations are handled manually due to a recursive issue.
@param object Any data type that can be converted to JSON
@return The JSON form of the given object, or `null` if an error was encountered]]></Description>
					<X>230</X><Y>90</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[object]]></Name>
						<Type><![CDATA[Object]]></Type>
					</Parameter>
					<Body><![CDATA[return toJson(object, false);]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[T]]></ReturnType>
					<Id>1665787820176</Id>
					<Name><![CDATA[fromJson]]></Name>
					<Description><![CDATA[Converts a JSON string to a POJO (i.e., not an AnyLogic-based class - namely agent or agent population types)
Example 1: {@code List<Integer> nums = fromJson("[1, 2, 4, 8]", List.class);}
Example 2: {@code List<Integer> nums = fromJson("input_list.json", List.class);}
@param json A JSON string to be converted <i>or</i> a path to a file with this information
@param clazz The class - specifically a standard Java type - to convert the provided string to
@return The object of the specified type (or `null` if errors were encountered)]]></Description>
					<CustomModifierCode><![CDATA[public static <T>]]></CustomModifierCode>                 	
					<X>380</X><Y>90</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[json]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[clazz]]></Name>
						<Type><![CDATA[Class<T>]]></Type>
					</Parameter>
					<Body><![CDATA[return fromJson(json, null, clazz);]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[HashMap<String, Object>]]></ReturnType>
					<Id>1665787820180</Id>
					<Name><![CDATA[agentToMap]]></Name>
					<Description><![CDATA[A helper function for serializing agents.
@param agent The agent to convert
@param includeNullFields Whether any fields with value `null` are included in the output
@param seenAgents A set of already parsed agents, used to avoid recursive conversion; can be null
@return A map of all public fields in the agent to their value]]></Description>
					<X>210</X><Y>460</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[agent]]></Name>
						<Type><![CDATA[Agent]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[includeNullFields]]></Name>
						<Type><![CDATA[boolean]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[seenAgents]]></Name>
						<Type><![CDATA[HashSet<Object>]]></Type>
					</Parameter>
					<Body><![CDATA[//traceln("Converting agent '%s' of type: %s", agent.getName(), agent.getClass());
if (seenAgents == null) seenAgents = new HashSet<Object>();

// field mapping, name to value
HashMap<String, Object> map = new HashMap<>();

// store index if part of population (individual agents will have index of -1)
//	(using internal prefixes ["_"], to not confuse w/any potential user vars of the same name)
if (agent.getIndex() >= 0) {
	// new: dont add index if part of default population
	if (agent.getPopulation() != null && !agent.getDefaultPopulation().equals(agent.getPopulation()))
		map.put("_index", agent.getIndex());
}

// generic agents should return immediately
if (agent.getClass().equals(Agent.class)) {
	return map;
}

// for custom agent types, use reflection to get all fields inside of agent
Field[] fields = agent.getClass().getFields();
String name;
Object value;
for (Field field : fields) {
	name = field.getName();
	
	//traceln("Examining field named '%s' (type: %s)...", name, field.getType());
	//traceln("  -> %s - %s", field.getType().getPackageName(), field.getType().getSimpleName());
	
	// skip known internal or problematic fields
	//	(e.g., for the scale, connections, internal datasets, etc.)
	// also skip common classes with assumed insignificance (e.g., shapes)
	if (jsonFilter.skipJsonifying(field.getName(), field.getModifiers(), field.getType())) {
		//traceln("\tSkipping!");
		continue;
	}
	
	// skip for links back to agents
	if (field.getAnnotations().length > 0 
			&& field.getAnnotations()[0].annotationType().equals(AnyLogicCustomSerialization.class) 
			&& Modifier.isTransient(field.getModifiers())) {
		continue;	
	}
	
	// skip for constants/enums
	if (Modifier.isStatic(field.getModifiers())) {
		//traceln("\tSkipping!");
		continue;
	}
	
	// skip for agent populations with types that hshould be filtered
	//if (value instanceof AgentArrayList)
		
	try {
		field.trySetAccessible(); 
		value = field.get(agent);
		//traceln("\tValue is of type: %s", value.getClass());
		if (value == null) {
			//traceln("\tSkipping!");
		}
		// skip if value is top-level agent
		else if (value.equals(agent.getRootAgent())) {
			//traceln("\tSkipping!");
			continue;
		}
		// apply this agent func for single agents
		else if (value instanceof Agent) {
			// skip if already seen
			if (seenAgents.contains(value)) {
				//traceln("\tSkipping!");
				continue;
			}
			//traceln("\t%s IS AGENT; CONVERTING TO MAP!", name);
			seenAgents.add((Agent)value); // XXX - Added to resolve stackoverflow when using toJson with no filters
			value = agentToMap((Agent)value, includeNullFields, seenAgents);
		}
		// apply other agent func for populations 
		else if (value instanceof AgentArrayList) {
			// skip if already seen
			if (seenAgents.contains(value)) {
				//traceln("\tSkipping!");
				continue;
			}
			//traceln("\t%s IS AGENTPOP; CONVERTING TO LIST!", name);
			
			value = agentPopToList((AgentArrayList)value, includeNullFields, seenAgents);
		}
		// handle when value is a collection/map holding an incompatible AnyLogic type
		else if (value instanceof Collection || value instanceof Map) {
			boolean skip = false;
			//traceln("\tCollection named '%s', of type %s", name, value.getClass());
			for (java.lang.reflect.Type type : ((ParameterizedType)field.getGenericType()).getActualTypeArguments()) {
				//traceln("\t\tType named: %s of class %s", type.getTypeName(), type.getClass());
				try {
				
					if (jsonFilter.skipJsonifying( (Class)type )) {
						skip = true;
						break;
					}
					
				} catch (ClassCastException e) {
					skip = true;
					break;
				}
			}
			if (skip) {
				//traceln("\tSkipping!");
				continue;
			}
		}
		//traceln("\t%s: %s", name, value.getClass());
		map.put(name, value);
	} catch (IllegalAccessException e) {
		//traceln("\terrorred!!!!!");
		if (includeNullFields) {
			map.put(name, null);
		}
	}
}

//traceln(":: summary of types ::");
//map.forEach((k,v) -> traceln("'%s' -> %s (from: %s)", k, v.getClass().getSimpleName(), v.getClass().getPackageName()));
//traceln(":: ................ ::");
/*
try {
	traceln(agent);
	String s = objmapper.writeValueAsString(map);
	traceln("%s\n\n", s);
} catch (Exception e) {e.printStackTrace();}
*/

return map;]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[ObjectAgentType]]></ReturnType>
					<Id>1665787820182</Id>
					<Name><![CDATA[agentType]]></Name>
					<Description><![CDATA[Classifies an object based on its underlying class and how it serialization needs to happen.]]></Description>
					<X>210</X><Y>420</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[agentObj]]></Name>
						<Type><![CDATA[Object]]></Type>
					</Parameter>
					<Body><![CDATA[// if we've registered serializers, can just return as a normal java object
if (serializedClasses.stream().anyMatch(cls -> cls.isAssignableFrom(agentObj.getClass())))
	return ObjectAgentType.JAVA;

// TODO does type-3 return as expected? might need to use getComponentType/instanceof
if (agentObj instanceof Agent)
	return ObjectAgentType.AGENT_SINGLE;
else if (agentObj instanceof AgentArrayList)
	return ObjectAgentType.AGENT_POPULATION;
else if (agentObj instanceof Collection 
	&& ((Collection)agentObj).size() > 0)
	return ObjectAgentType.AGENT_COLLECTION;
return ObjectAgentType.JAVA;]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[ArrayList<HashMap<String, Object>>]]></ReturnType>
					<Id>1665787820184</Id>
					<Name><![CDATA[agentPopToList]]></Name>
					<Description><![CDATA[A helper function for serializing agent populations
@param agentPop The list of agents 
@param includeNullFields Whether any fields with value `null` are included in the output
@param seenAgents A set of already parsed agents, used to avoid recursive conversion; can be null
@return A list of Map objects, one for each converted agent in the population]]></Description>
					<X>210</X><Y>440</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[agentPop]]></Name>
						<Type><![CDATA[AgentArrayList<Agent>]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[includeNullFields]]></Name>
						<Type><![CDATA[boolean]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[seenAgents]]></Name>
						<Type><![CDATA[HashSet<Object>]]></Type>
					</Parameter>
					<Body><![CDATA[//traceln("Converting pop of size %s, type: %s", agentPop.size(), agentPop.getClass());
//traceln("=> %s", jsonFilter.skipJsonifying(agentPop.get(0).getClass()));
if (seenAgents == null) seenAgents = new HashSet<Object>();

// convert each individual agent in the population into a hashmap
ArrayList<HashMap<String, Object>> popList = new ArrayList<>();
// first check for filter
if (agentPop.size() > 0 && jsonFilter.skipJsonifying(agentPop.get(0).getClass())) {
	return popList;
}

for (Agent a : agentPop) {
	if (!seenAgents.contains(a)) {
		seenAgents.add(a);
		popList.add( agentToMap(a, includeNullFields, seenAgents) );
	}
};
return popList;]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[String]]></ReturnType>
					<Id>1665787820186</Id>
					<Name><![CDATA[toJson]]></Name>
					<Description><![CDATA[Converts the given object to JSON.
Note that agents and agent populations are handled manually due to a recursive issue.
@param object Any data type that can be converted to JSON
@param prettyprint Whether to output JSON in "pretty" format (with newlines, tabs, etc.)
@return The JSON form of the given object, or `null` if an error was encountered]]></Description>
					<X>210</X><Y>70</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[object]]></Name>
						<Type><![CDATA[Object]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[prettyprint]]></Name>
						<Type><![CDATA[boolean]]></Type>
					</Parameter>
					<Body><![CDATA[String output = null;
try {
	output = prettyprint
				? objmapper.writerWithDefaultPrettyPrinter().writeValueAsString(object)
				: objmapper.writeValueAsString(object);
} catch (JsonProcessingException e) {
	e.printStackTrace();
}
return output;]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[ArrayList]]></ReturnType>
					<Id>1665787820190</Id>
					<Name><![CDATA[fromPopulationJson]]></Name>
					<Description><![CDATA[A function specifically for converting the given JSON (an array of objects mapping parameter names to value) to an arraylist of agents.
Example 1: {@code ArrayList<Person> pop = fromPopulationJson("{\"options\": [{\"age\": 21, \"name\": \"Paul\"}, {\"age\": 30, \"name\": \"Tyler\"}]}", "/options", Person.class, this);}
Example 2: {@code ArrayList<Person> pop = fromPopulationJson("person_data.json", "/options", Person.class, this);}
@param json A JSON string **or** a path to a file with this information
@param pointer A JSON pointer expression to identify the part of the string to convert; if null or empty, uses the json String directly
@param agent_clazz The class of the AL agent type
@param anyAgent Literally any other active agent in your model; used to properly start the agent (you can use `this` to refer to the active agent you're calling it from).
@return ArrayList An ArrayList of the agents]]></Description>
					<CustomModifierCode><![CDATA[public static <T extends Agent>]]></CustomModifierCode>                 	
					<X>360</X><Y>250</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[json]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[pointer]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[agent_clazz]]></Name>
						<Type><![CDATA[Class<T>]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[anyAgent]]></Name>
						<Type><![CDATA[Agent]]></Type>
					</Parameter>
					<Body><![CDATA[// Expected JSON is an array, where each element represents an agent's JSON
// (e.g., "[{"_index":0}, {"_index":1}]")

// handle whether input is a JSON string or path to JSON file
json = fetchJson(json);

try {	
	// To properly get entirety of single agent, need to convert array to JsonNode
	JsonNode root = objmapper.readTree(json);
	// Get at specific pointer if it was provided
	if (pointer != null && !pointer.isEmpty())
		root = root.at(pointer);
	// Build the output array based on the number of agent jsons detected
	ArrayList<T> newPop = new ArrayList();
	// Run each child json's string thru `fromAgentJson` and add to output array
	for (int i = 0; i < root.size(); i++) {
		JsonNode child = root.get(i);
		String childJson = objmapper.writeValueAsString(child);
		T childAgent = fromAgentJson(childJson, agent_clazz, anyAgent);
		newPop.add(childAgent);
	}
	return newPop;
} catch (Exception e) {
	e.printStackTrace();
}

return null;]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[T]]></ReturnType>
					<Id>1665787820192</Id>
					<Name><![CDATA[fromAgentJson]]></Name>
					<Description><![CDATA[Converts a JSON string of parameter mapping to an active/initialized agent
The agent will be added to the specified population.
Example 1: {@code fromAgentJson("{\"options\": [{\"age\": 21, \"name\": \"Paul\"}, {\"age\": 30, \"name\": \"Tyler\"}]}", "/options/1", Person.class, peoplePop);}
Example 2: {@code fromAgentJson("person_data.json", "/options/1", Person.class, peoplePop);}
@param json A JSON string to be converted to an AL agent **or** a path to a file with this information
@param pointer A JSON pointer expression to identify the part of the string to convert; if null or empty, uses the json String directly
@param clazz The class of the AL agent type to convert the provided string to
@param population The population to add this agent to
@return The agent of the specified type (or `null` if errors were encountered)]]></Description>
					<CustomModifierCode><![CDATA[public static <T extends Agent>]]></CustomModifierCode>                 	
					<X>360</X><Y>190</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[json]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[pointer]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[clazz]]></Name>
						<Type><![CDATA[Class<T>]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[population]]></Name>
						<Type><![CDATA[AgentArrayList]]></Type>
					</Parameter>
					<Body><![CDATA[// handle whether input is a JSON string or path to JSON file
json = fetchJson(json);

// Agent is "generic" when not alive/started
boolean genericAgent = population == null;

try {
	T myAgent;
	if (genericAgent) {
		myAgent = clazz
				.getDeclaredConstructor()
				.newInstance();
	} else {
		myAgent = clazz
					.getDeclaredConstructor(Engine.class, Agent.class, AgentList.class)
					.newInstance(population.getOwner().getEngine(), population.getOwner(), population);
		population._add(myAgent);
	}
	
	// add hacky workaround for not being able to add `throws` definitions in function
	Exception exception = setupAgentParameters(myAgent, json, pointer);
	if (exception != null) {
		throw exception;
	}
	
	// Create and start if "living" agent
	if (!genericAgent) {
		int index = population.size();
		population.callCreate(myAgent, index);
		myAgent.start();
	}
	
	return myAgent;
} catch (Exception e) {
	e.printStackTrace();
}
return null;]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[AgentArrayList]]></ReturnType>
					<Id>1665787820194</Id>
					<Name><![CDATA[fromPopulationJson]]></Name>
					<Description><![CDATA[Converts a list of agents from JSON (specifically an array of objects mapping parameter names to value) and adds it to an existing population.
Example 1: {@code fromPopulationJson("{\"options\": [{\"age\": 21, \"name\": \"Paul\"}, {\"age\": 30, \"name\": \"Tyler\"}]}", "/options", Person.class, peoplePop);}
Example 2: {@code fromPopulationJson("person_data.json", "/options", Person.class, peoplePop);}
@param json A valid JSON array **or** a path to a file with this information
@param pointer A JSON pointer expression to identify the part of the string to convert; if null or empty, uses the json String directly
@param agent_clazz The Java class for the agent type to convert to
@param population The population to add the agents to]]></Description>
					<CustomModifierCode><![CDATA[public static <T extends Agent>]]></CustomModifierCode>                 	
					<X>360</X><Y>290</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[json]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[pointer]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[agent_clazz]]></Name>
						<Type><![CDATA[Class<T>]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[population]]></Name>
						<Type><![CDATA[AgentArrayList]]></Type>
					</Parameter>
					<Body><![CDATA[// Expected JSON is an array, where each element represents an agent's JSON
// (e.g., "[{"_index":0}, {"_index":1}]")

// handle whether input is a JSON string or path to JSON file
json = fetchJson(json);

try {	
	// To properly get entirety of single agent, need to convert array to JsonNode
	JsonNode root = objmapper.readTree(json);
	// Get at specific pointer if it was provided
	if (pointer != null && !pointer.isEmpty())
		root = root.at(pointer);
	// Run each child json's string thru `fromAgentJson` and add to output array
	for (int i = 0; i < root.size(); i++) {
		JsonNode child = root.get(i);
		String childJson = objmapper.writeValueAsString(child);
		fromAgentJson(childJson, agent_clazz, population);
	}
} catch (Exception e) {
	e.printStackTrace();
}]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[T]]></ReturnType>
					<Id>1665787820198</Id>
					<Name><![CDATA[fromAgentJson]]></Name>
					<Description><![CDATA[Converts a JSON string of parameter mapping to an active/initialized agent.
Example 1: {@code Person p = fromAgentJson("{\"age\": 30, \"name\": \"Tyler\"}", Person.class, this);}
Example 2: {@code Person p = fromAgentJson("single_agent.json", Person.class, this);}
@param json A JSON string to be converted to an AL agent **or** a path to a file with this information
@param clazz The class of the AL agent type to convert the provided string to
@param anyAgent Literally any other active agent in your model; used to properly start the agent (you can use `this` to refer to the active agent you're calling it from).
@return The agent of the specified type (or `null` if errors were encountered)]]></Description>
					<CustomModifierCode><![CDATA[public static <T extends Agent>]]></CustomModifierCode>                 	
					<X>380</X><Y>150</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[json]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[clazz]]></Name>
						<Type><![CDATA[Class<T>]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[anyAgent]]></Name>
						<Type><![CDATA[Agent]]></Type>
					</Parameter>
					<Body><![CDATA[return Jsonifier.fromAgentJson(json, null, clazz, anyAgent);]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[Object]]></ReturnType>
					<Id>1673381927099</Id>
					<Name><![CDATA[getObjectOfName]]></Name>
					<Description><![CDATA[A helper function for finding the value of a named field.
If errors are encountered, they'll be printed out.
@param name The name of the object desired to be outputted
@param agent The active, valid agent which has the field
@return  The object or null if the name could not be found]]></Description>
					<X>360</X><Y>440</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[name]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[agent]]></Name>
						<Type><![CDATA[Agent]]></Type>
					</Parameter>
					<Body><![CDATA[// note: called by 'fromAgentJson'

Object obj = null;
try {
	obj = agent.getClass().getField(name).get(agent);
} catch (Exception e) {
	e.printStackTrace();
}
return obj;]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[T]]></ReturnType>
					<Id>1678298911650</Id>
					<Name><![CDATA[fromAgentJson]]></Name>
					<Description><![CDATA[Converts a JSON string of parameter mapping to an active agent, initialized from the root level agent.
This function will only work if called from the AnyLogic editor with the Jsonifier object created as an agent itself (i.e., not programmatically) or manually initialized by calling its `createAndStart` function.
Example 1: {@code Person p = fromAgentJson("{\"age\": 30, \"name\": \"Tyler\"}", Person.class);}
Example 2: {@code Person p = fromAgentJson("single_agent.json", Person.class);}
@param json A JSON string to be converted to an AL agent **or** a path to a file with this information
@param clazz The class of the AL agent type to convert the provided string to
@return The agent of the specified type (or `null` if errors were encountered)]]></Description>
					<CustomModifierCode><![CDATA[public <T extends Agent>]]></CustomModifierCode>                 	
					<X>400</X><Y>170</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[json]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[clazz]]></Name>
						<Type><![CDATA[Class<T>]]></Type>
					</Parameter>
					<Body><![CDATA[return Jsonifier.fromAgentJson(json, clazz, getRootAgent());]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[double]]></ReturnType>
					<Id>1678300792532</Id>
					<Name><![CDATA[writeFile]]></Name>
					<Description><![CDATA[Write some content to a file.
If the file already exists, content will be overridden.
Any errors will be printed to the console.
@param file The path to a file on the local system to write to
@param content The text to write to the file]]></Description>
					<X>210</X><Y>400</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[file]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[content]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Body><![CDATA[try {
	FileWriter myWriter = new FileWriter(file);
	myWriter.write(content);
	myWriter.close();
} catch (IOException e) {
	e.printStackTrace();
}]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[String]]></ReturnType>
					<Id>1678301012847</Id>
					<Name><![CDATA[readFile]]></Name>
					<Description><![CDATA[Read some content from a file.
Any errors will be printed to the console.
@param file The path to a file on the local system to read
@return The file content or null if the file was not found]]></Description>
					<X>360</X><Y>400</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[file]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Body><![CDATA[String output = null;
try {
	StringBuilder builder = new StringBuilder();
	File myObj = new File(file);
	Scanner myReader = new Scanner(myObj);
	while (myReader.hasNextLine()) {
		builder.append(myReader.nextLine());
	}
	myReader.close();
	output = builder.toString();
} catch (FileNotFoundException e) {
	e.printStackTrace();
}
return output;]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[String]]></ReturnType>
					<Id>1678309101105</Id>
					<Name><![CDATA[fetchJson]]></Name>
					<Description><![CDATA[Will convert the given input to a JSON string, if it's not already one.
@param input Text to evaluate; can be a JSON string, local file path, or url
@return a JSON string
@throws RuntimeException if the type of input is ambiguous or could not be found]]></Description>
					<X>360</X><Y>420</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[input]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Body><![CDATA[input = input.strip();
if (input.startsWith("{") || input.startsWith("[")) {
	// assume JSON string
	return input;
}

// check if it's a file system path...
java.nio.file.Path p = Paths.get(input);
if (p.toFile().exists()) {
	return readFile(input);
}

// check if it's a url
// ref: https://stackoverflow.com/a/17773849
final String urlRegex = "(https?:\\/\\/(?:www\\.|(?!www))[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\\.[^\\s]{2,}|www\\.[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\\.[^\\s]{2,}|https?:\\/\\/(?:www\\.|(?!www))[a-zA-Z0-9]+\\.[^\\s]{2,}|www\\.[a-zA-Z0-9]+\\.[^\\s]{2,})";
if (input.matches(urlRegex)) {
	try {
	    URL url = new URL(input);
	    Scanner scanner = new Scanner(url.openStream());
	    scanner.useDelimiter("\\A"); // Read the entire content as a single string
	    String content = scanner.next();
	    scanner.close();
	    
	    return content;
    } catch (IOException e) {
        throw new RuntimeException(String.format("Failed to read input '%s' as a url due to error: %s", input, e));
    }
}

throw new RuntimeException("Could not judge whether the input is a valid JSON string, file path, or url path: " + input);]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="false">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[String]]></ReturnType>
					<Id>1678310009514</Id>
					<Name><![CDATA[toJson]]></Name>
					<Description><![CDATA[Converts the given object to JSON and write it to the given file (will overwrite it if it exists) without pretty printing.
Note that agents and agent populations are handled manually due to a recursive issue.
@param object Any data type that can be converted to JSON
@param file The path to the desried JSON output file; can be relative to the working directory]]></Description>
					<X>250</X><Y>130</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[object]]></Name>
						<Type><![CDATA[Object]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[file]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Body><![CDATA[toJson(object, false, file);]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="false">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[String]]></ReturnType>
					<Id>1678310051457</Id>
					<Name><![CDATA[toJson]]></Name>
					<Description><![CDATA[Converts the given object to JSON and write it to a file (it will overwrite if it exists).
Note that agents and agent populations are handled manually due to a recursive issue.
@param object Any data type that can be converted to JSON
@param prettyprint Whether to output JSON in "pretty" format (with newlines, tabs, etc.)
@param file The path to the desried JSON output file; can be relative to the working directory]]></Description>
					<X>230</X><Y>110</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[object]]></Name>
						<Type><![CDATA[Object]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[prettyprint]]></Name>
						<Type><![CDATA[boolean]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[file]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Body><![CDATA[String output = toJson(object, prettyprint);
writeFile(file, output);]]></Body>
				</Function>
				<Function AccessType="private" StaticFunction="true">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[ObjectMapper]]></ReturnType>
					<Id>1678394507287</Id>
					<Name><![CDATA[createMapper]]></Name>
					<X>80</X><Y>90</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[ObjectMapper mapper = new ObjectMapper();
mapper.addMixInAnnotations(Event.class, SharedSuppressionMixIn.class); // TODO change to more generic parent type?
mapper.addMixInAnnotations(Port.class, PortSuppressionMixIn.class);

Serializers.register(
	mapper, 
	Arrays.stream(Serializers.class.getDeclaredClasses()).filter(c -> !Modifier.isAbstract(c.getModifiers())).toArray(Class[]::new) 
);

Deserializers.register(
	mapper,
	Arrays.stream(Deserializers.class.getDeclaredClasses()).filter(c -> !Modifier.isAbstract(c.getModifiers())).toArray(Class[]::new)
);

return mapper;]]></Body>
				</Function>
				<Function AccessType="public" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[String]]></ReturnType>
					<Id>1678400422725</Id>
					<Name><![CDATA[toString]]></Name>
					<X>60</X><Y>150</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Body><![CDATA[return jsonFilter.toString();]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[T]]></ReturnType>
					<Id>1682542721746</Id>
					<Name><![CDATA[fromJson]]></Name>
					<Description><![CDATA[Converts a JSON string to a POJO (i.e., not an AnyLogic-based class - namely agent or agent population types)
Example 1: {@code List<Integer> nums = fromJson("{\"inputs\": {\"num_lists\": [ [0], [1, 2, 4, 8] ]}}", "/inputs/num_lists/1", List.class);}
Example 2: {@code List<Integer> nums = fromJson("input_data.json", "/inputs/num_lists/1", List.class);}
@param json A JSON string to be converted <i>or</i> a path to a file with this information
@param pointer A JSON pointer expression to identify the part of the string to convert; if null or empty, uses the json String directly
@param clazz The class - specifically a standard Java type - to convert the provided string to
@return The object of the specified type (or `null` if errors were encountered)]]></Description>
					<CustomModifierCode><![CDATA[public static <T>]]></CustomModifierCode>                 	
					<X>360</X><Y>70</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[json]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[pointer]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[clazz]]></Name>
						<Type><![CDATA[Class<T>]]></Type>
					</Parameter>
					<Body><![CDATA[// handle whether input is a JSON string or path to JSON file
json = fetchJson(json);

T output = null;

// Agent related conversion require specialize functions
if (Agent.class.isAssignableFrom(clazz) || AgentList.class.isAssignableFrom(clazz)) {
	try {
		throw new Exception("Need to use `fromPopulationJson` for converting agent populations (returning null)");
	} catch (Exception e) {e.printStackTrace();}
	return null;
}

try {
	JsonNode root = objmapper.readTree(json);
	JsonNode target = pointer == null || pointer.isEmpty() ? root : root.at(pointer);
	output = objmapper.treeToValue(target, clazz);
} catch (IOException e) {
	e.printStackTrace();
}
return output;]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[T]]></ReturnType>
					<Id>1682543731263</Id>
					<Name><![CDATA[fromAgentJson]]></Name>
					<Description><![CDATA[Converts a JSON string of parameter mapping to an active/initialized agent.
Example 1: {@code Person p = fromAgentJson("{\"options\": [{\"age\": 21, \"name\": \"Paul\"}, {\"age\": 30, \"name\": \"Tyler\"}]}", "/options/1", Person.class, this);}
Example 2: {@code Person p = fromAgentJson("person_data.json", "/options/1", Person.class, this);}
@param json A JSON string to be converted to an AL agent **or** a path to a file with this information
@param pointer A JSON pointer expression to identify the part of the string to convert; if null or empty, uses the json String directly
@param clazz The class of the AL agent type to convert the provided string to
@param anyAgent Literally any other active agent in your model; used to properly start the agent (you can use `this` to refer to the active agent you're calling it from).
@return The agent of the specified type (or `null` if errors were encountered)]]></Description>
					<CustomModifierCode><![CDATA[public static <T extends Agent>]]></CustomModifierCode>                 	
					<X>360</X><Y>130</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[json]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[pointer]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[clazz]]></Name>
						<Type><![CDATA[Class<T>]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[anyAgent]]></Name>
						<Type><![CDATA[Agent]]></Type>
					</Parameter>
					<Body><![CDATA[// handle whether input is a JSON string or path to JSON file
json = fetchJson(json);

// Don't let the user try to avoid passing an active agent
if (anyAgent == null || anyAgent.getEngine() == null) {
	throw new RuntimeException(String.format("Argument 'anyAgent' must be a valid, active Agent ... was given '%s' (engine = %s)", anyAgent, anyAgent==null?null:anyAgent.getEngine()));
}

try {
	T myAgent = clazz
			.getDeclaredConstructor()
			.newInstance();
		
	// add hacky workaround for not being able to add `throws` definitions in function	
	Exception exception = setupAgentParameters(myAgent, json, pointer);
	if (exception != null) {
		throw exception;
	}

	// fully initialize the agent / "awaken" it
	myAgent.createAndStart(anyAgent);
	
	return myAgent;
} catch (Exception e) {
	e.printStackTrace();
}
return null;]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[T]]></ReturnType>
					<Id>1682543917517</Id>
					<Name><![CDATA[fromAgentJson]]></Name>
					<Description><![CDATA[Converts a JSON string of parameter mapping to an active/initialized agent
The agent will be added to the specified population.
Example 1: {@code fromAgentJson("{\"age\": 30, \"name\": \"Tyler\"}", Person.class, peoplePop);}
Example 2: {@code fromAgentJson("single_agent.json", Person.class, peoplePop);}
@param json A JSON string to be converted to an AL agent **or** a path to a file with this information
@param clazz The class of the AL agent type to convert the provided string to
@param population The population to add this agent to
@return The agent of the specified type (or `null` if errors were encountered)]]></Description>
					<CustomModifierCode><![CDATA[public static <T extends Agent>]]></CustomModifierCode>                 	
					<X>380</X><Y>210</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[json]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[clazz]]></Name>
						<Type><![CDATA[Class<T>]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[population]]></Name>
						<Type><![CDATA[AgentArrayList]]></Type>
					</Parameter>
					<Body><![CDATA[return Jsonifier.fromAgentJson(json, null, clazz, population);]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[ArrayList]]></ReturnType>
					<Id>1682543923418</Id>
					<Name><![CDATA[fromPopulationJson]]></Name>
					<Description><![CDATA[A function specifically for converting the given JSON (an array of objects mapping parameter names to value) to an arraylist of agents.
Example 1: {@code ArrayList<Person> pop = fromPopulationJson("[{\"age\": 21, \"name\": \"Paul\"}, {\"age\": 30, \"name\": \"Tyler\"}]", Person.class, this);}
Example 2: {@code ArrayList<Person> pop = fromPopulationJson("person_list.json", Person.class, this);}
@param json A JSON string **or** a path to a file with this information
@param agent_clazz The class of the AL agent type
@param anyAgent Literally any other active agent in your model; used to properly start the agent (you can use `this` to refer to the active agent you're calling it from).
@return ArrayList An ArrayList of the agents]]></Description>
					<CustomModifierCode><![CDATA[public static <T extends Agent>]]></CustomModifierCode>                 	
					<X>380</X><Y>270</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[json]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[agent_clazz]]></Name>
						<Type><![CDATA[Class<T>]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[anyAgent]]></Name>
						<Type><![CDATA[Agent]]></Type>
					</Parameter>
					<Body><![CDATA[return Jsonifier.fromPopulationJson(json, null, agent_clazz, anyAgent);]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>VOID</ReturnModificator>
					<ReturnType><![CDATA[AgentArrayList]]></ReturnType>
					<Id>1682543925517</Id>
					<Name><![CDATA[fromPopulationJson]]></Name>
					<Description><![CDATA[Converts a list of agents from JSON (specifically an array of objects mapping parameter names to value) and adds it to an existing population.
Example 1: {@code fromPopulationJson("[{\"age\": 21, \"name\": \"Paul\"}, {\"age\": 30, \"name\": \"Tyler\"}]", Person.class, peoplePop);}
Example 2: {@code fromPopulationJson("person_list.json", Person.class, peoplePop);}
@param json A valid JSON array **or** a path to a file with this information
@param agent_clazz The Java class for the agent type to convert to
@param population The population to add the agents to]]></Description>
					<CustomModifierCode><![CDATA[public static <T extends Agent>]]></CustomModifierCode>                 	
					<X>380</X><Y>310</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[json]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[agent_clazz]]></Name>
						<Type><![CDATA[Class<T>]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[population]]></Name>
						<Type><![CDATA[AgentArrayList]]></Type>
					</Parameter>
					<Body><![CDATA[Jsonifier.fromPopulationJson(json, null, agent_clazz, population);]]></Body>
				</Function>
				<Function AccessType="default" StaticFunction="false">
					<ReturnModificator>RETURNS_VALUE</ReturnModificator>
					<ReturnType><![CDATA[Exception]]></ReturnType>
					<Id>1684181406462</Id>
					<Name><![CDATA[setupAgentParameters]]></Name>
					<Description><![CDATA[A helper function shared by some of the 'from' functions to initialize an agent's parameters from JSON. Makes the change to the agent directly.
@param myAgent An instance of an agent
@param json A JSON string which contains a map of parameter names to intended values, somewhere in its content
@param pointer A JSON pointer expression to identify the part of the string to convert; if null or empty, uses the json String directly
@return Null if no problems occured, otherwise the encountered exception]]></Description>
					<CustomModifierCode><![CDATA[private static <T extends Agent>]]></CustomModifierCode>                 	
					<X>360</X><Y>460</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<Parameter>
						<Name><![CDATA[myAgent]]></Name>
						<Type><![CDATA[T]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[json]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Parameter>
						<Name><![CDATA[pointer]]></Name>
						<Type><![CDATA[String]]></Type>
					</Parameter>
					<Body><![CDATA[// User may have only passed a subset of parameters,
//	so try to set them all to defaults first.
// Note: cannot always call this because will throw null exception when default values 
//	reference function that require non-static usage (e.g., random functions)
try {
	myAgent.setParametersToDefaultValues();
} catch (NullPointerException e) {
	// At least mark as set
	myAgent.markParametersAreSet();
}

Exception exception = null;

try {
	// update the reference node by the pointer
	JsonNode jsonNode = objmapper.readTree(json);
	if (pointer != null && !pointer.isEmpty() )
		jsonNode = jsonNode.at(pointer);
	
	// loop thru the fields and find/set the matching parameter name
	Iterator<String> iter = jsonNode.fieldNames();
	while (iter.hasNext()) {
		String fieldName = iter.next();
		// _index is one added by me
		if (fieldName.equals("_index"))
			continue;
		// 'catch-all' method to turn any jsonnode to its intended type
		//	without having to switch over the class
		JsonNode fieldNode = jsonNode.get(fieldName);
		Class<?> cls = myAgent.getClass().getField(fieldName).getType();
		Object value;
		try {
			value = objmapper.treeToValue(fieldNode, cls);
		} catch (InvalidFormatException _e) {
			// mismatch between JSON type and cls
			
			// try evaluating as if it's code 
			//	(but only possible if this object was setup as an agent -- i.e., not in an external env)
			if (root != null) {
				value = root.executeExpression(cls, fieldNode.asText());
			} else {
				throw _e;
			}
		}
		
		boolean result;
		try {
			result = myAgent.setParameter(fieldName, value, false);
		} catch (ClassCastException e) {
			// assume value is a string referring to a named object in the jsonNode agent
			Object adjustedValue = getObjectOfName(value.toString(), myAgent.getRootAgent());
			result = myAgent.setParameter(fieldName, adjustedValue, false);
		}
		// alert user, but only once per run
		if (!result && !warnedParameters.contains(fieldName)) {
			traceln("ONE-TIME WARNING: Parameter '%s' not found! Options: %s", fieldName, Arrays.toString(myAgent.getParameterNames()));
			warnedParameters.add(fieldName);
		}
	}
} catch (NoSuchFieldException | JsonProcessingException e) {
	exception = e;
}
return exception;]]></Body>
				</Function>
			</Functions>
			<AgentLinks>
				<AgentLink>
					<Id>1665787765894</Id>
					<Name><![CDATA[connections]]></Name>
					<X>50</X><Y>-50</Y>
					<Label><X>15</X><Y>0</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>true</ShowLabel>
					<HandleReceiveInConnections>false</HandleReceiveInConnections>
					<AgentLinkType>COLLECTION_OF_LINKS</AgentLinkType>
					<AgentLinkBidirectional>true</AgentLinkBidirectional>
					<MessageType><![CDATA[Object]]></MessageType>
					<LineStyle>SOLID</LineStyle>
					<LineWidth>1</LineWidth>
					<LineColor>-16777216</LineColor>
					<LineZOrder>UNDER_AGENTS</LineZOrder>
					<LineArrow>NONE</LineArrow>
					<LineArrowPosition>END</LineArrowPosition>
				</AgentLink>
			</AgentLinks>


			<Presentation>
				<Level>
					<Id>1665787765898</Id>
					<Name><![CDATA[level]]></Name>
					<X>0</X><Y>0</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<Z>0</Z>
					<LevelVisibility>DIM_NON_CURRENT</LevelVisibility>

			<Presentation>
				<Image>
					<Id>1665791283971</Id>
					<Name><![CDATA[image]]></Name>
					<X>-8</X><Y>-8</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<OnClickCode><![CDATA[return true;]]></OnClickCode>
					<EmbeddedIcon>true</EmbeddedIcon>
					<Z>0</Z>
					<Width>16</Width>
					<Height>16</Height>
					<Rotation>0.0</Rotation>
					<ImageFiles>
						<ImageResourceReference>
							<PackageName><![CDATA[com.anylogic.libraries.pypeline]]></PackageName>
							<ClassName><![CDATA[jsonifier_16.png]]></ClassName>
						</ImageResourceReference>
					</ImageFiles>
					<OriginalSize>true</OriginalSize>
				</Image>
				<Text>
					<Id>1678300425032</Id>
					<Name><![CDATA[text1]]></Name>
					<X>200</X><Y>40</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-16777216</Color>
					<Text><![CDATA[To-JSON variants
]]></Text>
					<Font>
						<Name>SansSerif</Name>
						<Size>10</Size>
						<Style>1</Style>
					</Font>
					<Alignment>LEFT</Alignment>
				</Text>
				<Text>
					<Id>1678300473785</Id>
					<Name><![CDATA[text2]]></Name>
					<X>350</X><Y>40</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-16777216</Color>
					<Text><![CDATA[From-JSON variants
]]></Text>
					<Font>
						<Name>SansSerif</Name>
						<Size>10</Size>
						<Style>1</Style>
					</Font>
					<Alignment>LEFT</Alignment>
				</Text>
				<Text>
					<Id>1678300488541</Id>
					<Name><![CDATA[text3]]></Name>
					<X>190</X><Y>370</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-16777216</Color>
					<Text><![CDATA[To-JSON helpers]]></Text>
					<Font>
						<Name>SansSerif</Name>
						<Size>10</Size>
						<Style>1</Style>
					</Font>
					<Alignment>LEFT</Alignment>
				</Text>
				<Text>
					<Id>1678300495277</Id>
					<Name><![CDATA[text4]]></Name>
					<X>350</X><Y>370</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-16777216</Color>
					<Text><![CDATA[From-JSON helpers]]></Text>
					<Font>
						<Name>SansSerif</Name>
						<Size>10</Size>
						<Style>1</Style>
					</Font>
					<Alignment>LEFT</Alignment>
				</Text>
				<Text>
					<Id>1678300553340</Id>
					<Name><![CDATA[text5]]></Name>
					<X>50</X><Y>40</Y>
					<Label><X>0</X><Y>-10</Y></Label>
					<PublicFlag>false</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-16777216</Color>
					<Text><![CDATA[Shared objects]]></Text>
					<Font>
						<Name>SansSerif</Name>
						<Size>10</Size>
						<Style>1</Style>
					</Font>
					<Alignment>LEFT</Alignment>
				</Text>
			</Presentation>

				</Level>
			</Presentation>

		</ActiveObjectClass>
	</ActiveObjectClasses>	
	<DifferentialEquationsMethod>EULER</DifferentialEquationsMethod>
	<MixedEquationsMethod>RK45_NEWTON</MixedEquationsMethod>
	<AlgebraicEquationsMethod>MODIFIED_NEWTON</AlgebraicEquationsMethod>
	<AbsoluteAccuracy>1.0E-5</AbsoluteAccuracy>
	<FixedTimeStep>0.001</FixedTimeStep>
	<RelativeAccuracy>1.0E-5</RelativeAccuracy>
	<TimeAccuracy>1.0E-5</TimeAccuracy>
	<Frame>
		<Width>1000</Width>
		<Height>600</Height>
	</Frame>
	<Database>
		<Logging>false</Logging>
		<AutoExport>false</AutoExport>
		<ShutdownCompact>false</ShutdownCompact>
		<ImportSettings>
		</ImportSettings>
		<ExportSettings>
		</ExportSettings>
	</Database>
	
	<RunConfiguration ActiveObjectClassId="1569858524855">
		<Id>1567802082277</Id>
		<Name><![CDATA[RunConfiguration]]></Name>
		<MaximumMemory>512</MaximumMemory>
		<ModelTimeProperties>
			<StopOption><![CDATA[Stop at specified time]]></StopOption>
			<InitialDate><![CDATA[1567728000000]]></InitialDate>	
			<InitialTime><![CDATA[0.0]]></InitialTime>	
			<FinalDate><![CDATA[1570320000000]]></FinalDate>	
			<FinalTime><![CDATA[100.0]]></FinalTime>	
		</ModelTimeProperties>
		<AnimationProperties>
			<StopNever>true</StopNever>
			<ExecutionMode>realTimeScaled</ExecutionMode>
			<RealTimeScale>1.0</RealTimeScale>
			<EnableZoomAndPanning>true</EnableZoomAndPanning>
			<EnableDeveloperPanel>false</EnableDeveloperPanel>
			<ShowDeveloperPanelOnStart>false</ShowDeveloperPanelOnStart>
		</AnimationProperties>
		<Inputs>		
		</Inputs>
		<Outputs>
		</Outputs>
	</RunConfiguration>
	<Experiments>	
		<!--   =========   Simulation Experiment   ========  -->
		<SimulationExperiment ActiveObjectClassId="1569858524855">
			<Id>1685539151009</Id>
			<Name><![CDATA[Simulation]]></Name>
			<CommandLineArguments><![CDATA[]]></CommandLineArguments>
			<MaximumMemory>512</MaximumMemory>
			<RandomNumberGenerationType>fixedSeed</RandomNumberGenerationType>
			<CustomGeneratorCode>new Random()</CustomGeneratorCode>
			<SeedValue>1</SeedValue>
			<SelectionModeForSimultaneousEvents>LIFO</SelectionModeForSimultaneousEvents>
			<VmArgs><![CDATA[]]></VmArgs>
			<LoadRootFromSnapshot>false</LoadRootFromSnapshot>

			<Presentation>
				<Text>
					<Id>1685539151011</Id>
					<Name><![CDATA[text]]></Name>
					<X>50</X><Y>30</Y>
					<Label><X>10</X><Y>0</Y></Label>
					<PublicFlag>true</PublicFlag>
					<PresentationFlag>true</PresentationFlag>
					<ShowLabel>false</ShowLabel>
					<DrawMode>SHAPE_DRAW_2D3D</DrawMode>
					<EmbeddedIcon>false</EmbeddedIcon>
					<Z>0</Z>
					<Rotation>0.0</Rotation>
					<Color>-12490271</Color>
					<Text><![CDATA[Pypeline Library]]></Text>
					<Font>
						<Name>SansSerif</Name>
						<Size>24</Size>
						<Style>0</Style>
					</Font>
					<Alignment>LEFT</Alignment>
				</Text>
			</Presentation>

			<Parameters>			
				<Parameter>
					<ParameterName><![CDATA[enable]]></ParameterName>
				</Parameter>
				<Parameter>
					<ParameterName><![CDATA[loadLastWorkingConfig]]></ParameterName>
				</Parameter>
				<Parameter>
					<ParameterName><![CDATA[pythonCommandType]]></ParameterName>
				</Parameter>
				<Parameter>
					<ParameterName><![CDATA[pythonCommand]]></ParameterName>
				</Parameter>
				<Parameter>
					<ParameterName><![CDATA[pythonExecPath]]></ParameterName>
				</Parameter>
				<Parameter>
					<ParameterName><![CDATA[throwErrorOnFailedAttempt]]></ParameterName>
				</Parameter>
				<Parameter>
					<ParameterName><![CDATA[redirectPyOutput]]></ParameterName>
				</Parameter>
				<Parameter>
					<ParameterName><![CDATA[isBlacklistMode]]></ParameterName>
				</Parameter>
				<Parameter>
					<ParameterName><![CDATA[isCustomConfiguration]]></ParameterName>
				</Parameter>
				<Parameter>
					<ParameterName><![CDATA[includeAutogeneratedsBL]]></ParameterName>
				</Parameter>
				<Parameter>
					<ParameterName><![CDATA[includeAutogeneratedsWL]]></ParameterName>
				</Parameter>
				<Parameter>
					<ParameterName><![CDATA[includedPackagesBL]]></ParameterName>
				</Parameter>
				<Parameter>
					<ParameterName><![CDATA[includedPackagesWL]]></ParameterName>
				</Parameter>
				<Parameter>
					<ParameterName><![CDATA[includedClassesBL]]></ParameterName>
				</Parameter>
				<Parameter>
					<ParameterName><![CDATA[includedClassesWL]]></ParameterName>
				</Parameter>
				<Parameter>
					<ParameterName><![CDATA[includedNamesBL]]></ParameterName>
				</Parameter>
				<Parameter>
					<ParameterName><![CDATA[includedNamesWL]]></ParameterName>
				</Parameter>
			</Parameters>			
			<PresentationProperties>
				<EnableZoomAndPanning>true</EnableZoomAndPanning>
				<ExecutionMode><![CDATA[realTimeScaled]]></ExecutionMode>
				<Title><![CDATA[Pypeline Library : Simulation]]></Title>	
				<EnableDeveloperPanel>true</EnableDeveloperPanel>
				<ShowDeveloperPanelOnStart>false</ShowDeveloperPanelOnStart>
				<RealTimeScale>1.0</RealTimeScale>
			</PresentationProperties>
			<ModelTimeProperties>
				<StopOption><![CDATA[Never]]></StopOption>
				<InitialDate><![CDATA[1685491200000]]></InitialDate>	
				<InitialTime><![CDATA[0.0]]></InitialTime>	
				<FinalDate><![CDATA[1688083200000]]></FinalDate>	
				<FinalTime><![CDATA[100.0]]></FinalTime>	
			</ModelTimeProperties>
			<BypassInitialScreen>true</BypassInitialScreen>
		</SimulationExperiment>	
	</Experiments>
	<JavaClasses>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1569858562164</Id>
			<Name><![CDATA[PySubProcess]]></Name>
			<Text><![CDATA[import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.ObjectStreamException;
import java.io.OutputStream;
import java.net.Socket;
import java.nio.file.Paths;
import java.nio.file.Files;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.lang.ProcessBuilder.Redirect;
import java.net.URL;
import spark.utils.IOUtils;

import java.util.logging.Logger;
import java.util.logging.ConsoleHandler;
import java.util.logging.SimpleFormatter;
import java.util.logging.Formatter;
import java.util.logging.LogRecord;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;


/**
 * This object is created in the main communicator agent and works as the 'middleman' between your model and Python.
 * Specifically, it works by first locating your Python executable, then using that to start the server.py file.
 * Once it does that, it listens for what port the Python server is listening on (which it communicates via i/o streams) and then connects as a client.
 * It is then able to receive code passed from an AnyLogic model and communicates that to the Python server.
 * 
 * @author Tyler Wolfe-Adam
 */
public class PySubProcess {
	
	// the command that will be used to locate python - will be different for windows vs mac/linux
	public static final String findCmd = System.getProperty("os.name").toLowerCase().contains("win") ? "where" : "which";
	// the path to the python executable
	public String activePyPath = "";
	public String activePyVersion = "";
	public boolean redirectPyOutput;
	
	// out types
	public final static byte execMsg = 0;
	public final static byte evalMsg = 1;
	public final static byte pingMsg = 2;
	
	// in types
	public final static int successMsg = 0;
	public final static int errorMsg = 1;
	
	public Process proc = null;
	public Socket socket = null;
	
	public InputStream in = null;
	public OutputStream out = null;
	
	public InputStream stdout = null;
	public InputStream stderr = null;
	
	public ExecutorService executor = null;
	
	//private final static Logger logger = Logger.getLogger(PySubProcess.class.getName());
    
    /**
     * 
     * @param pathToPyExe
     * @param pathToServerPy
     */
    public PySubProcess(String pathToServerPy, String pathToPyExe, boolean redirectPyOutput, java.util.logging.Level logLevel) throws IOException, PyException, InterruptedException {
    	//logger.setUseParentHandlers(false);
    	/*ConsoleHandler handler = new ConsoleHandler();
    	handler.setLevel(logLevel);
    	handler.setFormatter(new SimpleFormatter() {
            private static final String format = "[%1$tT.%1$tN] [%2$-7s] %3$s %n";

            @Override
            public synchronized String format(LogRecord lr) {
                return String.format(format,
                        new Date(lr.getMillis()),
                        lr.getLevel().getLocalizedName(),
                        lr.getMessage()
                );
            }
        });*/
    	//logger.addHandler(handler);
    	//logger.setLevel(logLevel);
    	
    	activePyPath = pathToPyExe;
    	activePyVersion = getPythonVersion(activePyPath);
    	this.redirectPyOutput = redirectPyOutput;
	    initConnection(pathToServerPy);
		openStreams();
    }
    
    /**
     * 
     * @param pathToServerPy
     * @throws IOException
     * @throws Exception
     */
    private void initConnection(String pathToServerPy) throws IOException, PyException, InterruptedException {
    	//logger.info("Initializing connection");
    	
    	// First find/validate the path to the server.py file
    	final String serverPyFile = "server.py";
    	File workingDirectory = new File(System.getProperty("user.dir"));

    	// TODO - is the following needed? server.py is always a temp file with full dir given
    	if (pathToServerPy == null) // in case nothing was given, check in working directory
    		pathToServerPy = Paths.get(workingDirectory.toString(), serverPyFile).toString();
    	else if (!pathToServerPy.endsWith(".py")) // in case just directory was given
    		pathToServerPy = Paths.get(pathToServerPy, serverPyFile).toString();
    	
    	if (!new File(pathToServerPy).exists()) {
    		throw new IOException("Path to server python file does not exist: " + pathToServerPy);
    	}
    	
    	// Build and execute the command to run the server.py file
    	List<String> pythonCmd = Arrays.asList(activePyPath, pathToServerPy);
		ProcessBuilder pb = new ProcessBuilder(formatCommand(pythonCmd)).directory(workingDirectory);
		
		proc = pb.start();

		// The server.py file will print the port it's using to the standard output.
		// Capture the port it's using.
		String portLine = null;
		BufferedReader pbInput = new BufferedReader(new InputStreamReader(proc.getInputStream()));
		portLine = pbInput.readLine();
		
		if (portLine == null) {
			//BufferedReader pbError = new BufferedReader(new InputStreamReader(proc.getErrorStream()));
			String errorMsg = IOUtils.toString(proc.getErrorStream());
			throw new IOException("Python process failed to properly start. This process needs to be started by a 'live' agent. Error message from process: '" + errorMsg + "'");
		}
		
		int port = Integer.MIN_VALUE;
		try {
			port = Integer.parseInt(portLine);
		} catch (NumberFormatException e) {
			earlyFail("Python process did not provide a port to connect with -- are you using a valid Python executable?; read line: " + portLine);
		}
		
		// Connect to the server.py file via socket
		while (socket == null && proc.isAlive()) {
			try {
				socket = new Socket("localhost", port);
			} catch (IOException e) {
				// keep trying
				Thread.sleep(100);
			}
		}
		
		// Make sure the process is alive and running
		if (!proc.isAlive()) {
			earlyFail("Python process failed to start:");
		}
	}
    
    /**
     * Open the streams to and from the Python server
     */
    private void openStreams() {
    	try {
			in = socket.getInputStream();
			out = socket.getOutputStream();
			stdout = proc.getInputStream();
			stderr = proc.getErrorStream();
			executor = Executors.newSingleThreadExecutor();
		} catch (IOException e) {
			e.printStackTrace();
		}
    }
    
    /**
     * Generate an early failure with some given prefix text.
     * Useful, as it will also provide stdout and stderr.
     * @param prefix
     * @throws Exception
     */
    void earlyFail(String prefix) throws IOException, PyException {
		String stdoutOutput = readAllReady(new InputStreamReader(proc.getInputStream()));
		String stderrOutput = readAllReady(new InputStreamReader(proc.getErrorStream()));
		throw new PyException("[ERROR] " + prefix + (prefix.endsWith("\n") ? "" : "\n")
				+ (stderrOutput.isEmpty() ? "" : "Error stream message:\n" + stderrOutput)
				+ (stdoutOutput.isEmpty() ? "" : "Output stream message:\n" + stdoutOutput));
	}
    
    /**
     * Just ping the Python server to make sure it's still running.
     * @return Attempt
     */
    public Attempt ping() {
    	//logger.finer("ENTRY ping");
    	Attempt outcome = null;
    	if (socket.isClosed())
    		outcome = new Attempt(Attempt.RESULT_ERROR, "Python subprocess has been shutdown.");
    	else {
	    	try {
		    	out.write(pingMsg);
				out.flush();
		    	outcome = readAttemptResult();
	    	} catch (Throwable e) { // catchall
	    		outcome = new Attempt(e);
	    	}
    	}
    	//logger.finer(String.format("EXIT ping(%s)", outcome));
    	return outcome;
    	
    }
    
    /**
     * Execute a statement ("just run" / no expected return, other than the return code)
     * @param stmt The code to be executed
     * @return Attempt With empty feedback if successful, otherwise the error message
     */
    public Attempt exec(String stmt) {
    	//logger.finer("ENTRY exec(" + stmt + ")");
    	Attempt outcome = null;
    	try {
    		//logger.fine("Outputting exec message");
    		
    		//logger.finest("Writing exec message");
			out.write(execMsg);
			//logger.finest("Writing string statement");
			writeString(stmt);
			//logger.finest("Flushing");
			out.flush();
			
			//logger.fine("Reading attempt result");
			outcome = readAttemptResult();
    	} catch (Throwable e) { // catchall
    		outcome = new Attempt(e);
    	}
    	//logger.finer(String.format("EXIT exec(%s)", outcome));
    	return outcome;
	}
	
    /**
     * Evaluate an expression ("get value" / expecting a return)
     * @param expr the code to be evaluated
     * @return Attempt With a feedback of the returned value if no error, otherwise the error message
     */
	public Attempt eval(String expr) {
		//logger.finer("ENTRY eval(" + expr + ")");
		Attempt outcome = null;
		try {
			//logger.fine("Outputting eval message");
			
			//logger.finest("Writing eval message");
			out.write(evalMsg);
			//logger.finest("Writing string expression");
			writeString(expr);
			//logger.finest("Flushing");
			out.flush();
			
			//logger.fine("Reading attempt result");
	    	outcome = readAttemptResult();
		} catch (Exception e) {
			outcome = new Attempt(e);
		}
		//logger.finer(String.format("EXIT eval(%s)", outcome));
		return outcome;
	}
    
    private Attempt readAttemptResult() throws IOException {
    	//logger.finer("ENTRY readAttemptResult");
    	// Continue to dump standard input and standard error of process until received data from Python.
    	// Unhandled warn statements will block process from continuing (and are piped to standard error)
    	//logger.finest("Printing until in is no longer available");
    	while (in.available() == 0) {
    		printStdout();
    		printStderr();
    	}
    	//logger.finest("Reading byte");
    	byte resultCode = readByte();
    	//logger.finest("Reading string");
    	String feedback = readString();
    	
    	//logger.finest("Printing stdout/err");
    	printStdout();
    	printStderr();
    	
    	Attempt outcome = new Attempt(resultCode, feedback);
    	//logger.finer(String.format("EXIT readAttemptResult(%s)", outcome));
    	return outcome;
    }
    
    
    /**
     * Prints anything from the standard input stream (from the process)
     * @return String
     */
    private void printStdout() throws IOException {
    	// Display anything Python put into stdout (e.g., print statements)
    	int n = stdout.available();
    	if (n > 0) {
    		byte[] b = new byte[n];
    		stdout.read(b);
    		String s = (new String(b)).trim();
    		// start each line with '> ' to distinguish it for Console viewers
    		s = "> " + s.replaceAll("(\\r\\n|\\r|\\n)", "$1> ");
    		if (redirectPyOutput)
    			traceln(green, s);
    	}
    }
    
    /**
     * Prints anything from the standard error stream (from the process)
     * @return String
     */
    private void printStderr() throws IOException {
    	// Display anything Python put into stderr, that's not an exception/error (e.g., warn statements)
    	int n = stderr.available();
    	if (n > 0) {
    		byte[] b = new byte[n];
    		stderr.read(b);
    		String s = (new String(b)).trim();
    		// start each line with '> ' to distinguish it for Console viewers
    		s = "> " + s.replaceAll("(\\r\\n|\\r|\\n)", "$1> ");
    		if (redirectPyOutput)
    			traceln(red, s);
    	}
    }
	
	/**
	 * Read a number of bytes from the in stream
	 * @param numBytes how many bytes to read
	 * @return byte[]
	 * @throws IOException
	 */
	byte[] read(int numBytes) throws IOException {
		byte[] output = new byte[numBytes];
		for (int i = 0; i < numBytes; i++)
			output[i] = readByte();
		return output;
	}
	
	/**
	 * Read a single byte from the in stream
	 * @return byte
	 * @throws IOException
	 */
	byte readByte() throws IOException {
		int nextByte = in.read();
		if (nextByte == -1) {
			throw new IOException("Cannot read byte; reached end of stream");
		}
		return (byte) nextByte;
	}
	
	/**
	 * Read an integer (4 bytes) from the in stream
	 * @return int
	 * @throws IOException
	 */
	int readInt() throws IOException {
		return (readByte() << 24) & 0xff000000 |
				(readByte() << 16) & 0x00ff0000 | 
				(readByte() <<  8) & 0x0000ff00 |
				(readByte() <<  0) & 0x000000ff;
	}
	
	/**
	 * Read a string from the in stream (by first reading an integer to see how long the string will be)
	 * @return String
	 * @throws IOException
	 */
	String readString() throws IOException {
		int len = readInt();
		String output = new String(read(len), "UTF-8");
		return output;
	}
	
	/**
	 * Write an integer to the out stream
	 * @param i
	 * @throws IOException
	 */
	void writeInt(int i) throws IOException {
		byte[] b = new byte[] {
				(byte) (i >>> 24),
				(byte) (i >>> 16),
				(byte) (i >>> 8),
				(byte) i
		};
		out.write(b);
	}
	
	/**
	 * Write a string to the out stream (but first write the size [in bytes] as an integer)
	 * @param str
	 * @throws IOException
	 */
	void writeString(String str) throws IOException {
		byte[] b = str.getBytes();
		writeInt(b.length);
		out.write(b);
	}
	
	/**
	 * Close all streams and processes
	 * @throws Exception
	 */
	void close() throws Exception {
		executor.shutdownNow();
		// close down streams, ignoring if they throw errors
		try {
			in.close();
		} catch (IOException e) {}
		
		try {
			out.close();
		} catch (IOException e) {}
		
		try {
			socket.close();
		} catch (IOException e) {}
		
		proc.destroyForcibly();
		try {
			proc.waitFor(3, TimeUnit.SECONDS);
		} catch (InterruptedException e) {}
		if (proc.isAlive())
			throw new Exception("Python process failed to shutdown. Please shut it down via your process manager");
		
	}
	
	/**
	 * Helper function to format the command based on the operating system
	 * @param args
	 * @return List<String>
	 */
	public static List<String> formatCommand(List<String> args) {
		String os = System.getProperty("os.name").toLowerCase();
		/* TODO Why was this needed? Seemed to be causing problems, so removed for now.
		if (os.contains("mac")) {
			args.replaceAll(s -> "'" + s + "'");
			args.addAll(0, new ArrayList<>(Arrays.asList("/bin/bash", "-l", "-c")));
		}
		*/
		return args;
	}
	
	/**
	 * Read all ready strings
	 * @param in
	 * @return String
	 * @throws IOException
	 */
	public static String readAllReady(InputStream in) throws IOException {
		return readAllReady(new InputStreamReader(in));
	}
	
	/**
	 * Read all ready strings
	 * @param inReader
	 * @return String
	 * @throws IOException
	 */
	public static String readAllReady(InputStreamReader inReader) throws IOException {
		StringBuilder sbuilder = new StringBuilder();
		while (inReader.ready())
			sbuilder.append((char)inReader.read());
		return sbuilder.toString();
	}
	
	
	/**
	 * Helper function to convert the enum to the Python command
	 * @param preferredCommand
	 * @return String
	 */
	public static String convertToCommand(PythonCommandType preferredCommand) {
		switch (preferredCommand) {
			case PYTHON:
				return "python";
			case PYTHON2:
				return "python2";
			case PYTHON3:
				return "python3";
			default:
				return null;
		}
	}
	
	/**
	 * Locate the executable in user's path by running the 'find' command (or the OS-equivalent)
	 * @param pythonCommand
	 * @return String
	 */
	public static String findPythonPath(String pythonCommand) throws PyException {
		ProcessBuilder pb = new ProcessBuilder(findCmd, pythonCommand);
		pb.redirectError(Redirect.PIPE);
		pb.redirectInput(Redirect.PIPE);
		String loc = null;
		try {
			Process proc = pb.start();
			BufferedReader reader = new BufferedReader(new InputStreamReader(proc.getInputStream()));
			loc = reader.readLine();
		} catch (IOException e) {
			e.printStackTrace();
		} catch (NullPointerException e2) {
			throw new PyException("Failed to find Python path using command: " + pythonCommand);
		}
		return loc;
	}

	
	/**
	 * Helper function to get the specified Python version.
	 * (Just calls Python with the `--version` flag)
	 * @param pythonPath The path to the desired Python executable
	 * @return String
	 */
	public static String getPythonVersion(String pythonPath) throws IOException {
		ProcessBuilder pb = new ProcessBuilder(pythonPath, "--version");
		pb.redirectError(Redirect.PIPE);
		pb.redirectInput(Redirect.PIPE);

		Process proc = pb.start();
		BufferedReader reader = new BufferedReader(new InputStreamReader(proc.getInputStream()));
		String version = reader.readLine();

		// There's weird behavior when running on Mac's built-in Python 2,
		//	where the version gets printed out in the error stream (and input stream is null).
		// Handle if applicable.
		if (version == null)
			version = new BufferedReader(new InputStreamReader(proc.getErrorStream())).readLine();
		
		return version;
	}
}]]></Text>
		</JavaClass>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1569861582393</Id>
			<Name><![CDATA[Attempt]]></Name>
			<Text><![CDATA[import java.util.Arrays;
import java.io.IOException;
import com.fasterxml.jackson.databind.ObjectMapper;

/**
 * This object represents the results from the attempt that was made to execute some Python code.
 * It has two basic objects: one for determining the success of the command and the other for the response with additional data (referred to as the "feedback").<br>
 * If the code executed without errors, the feedback will contain either the requested data or some message indicating the success (depending on if using `run` or `runResults`).<br>
 * Otherwise, the feedback will contain the error message - this could be from Python or Java, depending on the specific problem.<br>
 * 
 * The following examples show what function is called and its argument, followed by what would be printed to the console.<br>
 * Some also have additional comments underneath to explain the results.<br>
 * Examples:<br>
 * &emsp; runResults("3+5") -> Attempt [isSuccessful=true, feedback=8]<br>
 * &emsp; run("3+5") -> Attempt [isSuccessful=true, feedback=]<br>
 * &emsp; run("3..5") -> Attempt [isSuccessful=false, feedback=SyntaxError('invalid syntax', ('<string>', 1, 4, '3..5\n'))]<br>
 * &emsp; runResults("foo()") -> Attempt [isSuccessful=false, feedback=NameError("name 'foo' is not defined",)]<br>
 * &emsp; run("def foo():", "  return 'hello'") -> Attempt [isSuccessful=true, feedback=]<br>
 * &emsp; runResults("foo()") -> Attempt [isSuccessful=true, feedback=hello]<br>
 * 
 * @author Tyler Wolfe-Adam
 */
public class Attempt {
	
	public static final int RESULT_SUCCESSFUL = 0;
	public static final int RESULT_ERROR = 1;
	
	private final int resultCode;
	private final String feedback;
	
	/**
	 * Initialize a new Attempt object as having been successful with null feedback
	 */
	public Attempt() {
		this(RESULT_SUCCESSFUL, null);
	}
	
	public Attempt(Throwable e) {
		this(RESULT_ERROR, e.getMessage());
	}
	
	/**
	 * Initialize a new Attempt object as determined by the arguments
	 * @param resultCode The static int indicating if the command executed successfully
	 * @param feedback The response received from running the command associated with this object
	 */
	public Attempt(int resultCode, String feedback) {
		this.resultCode = resultCode;
		this.feedback = feedback;
	}

	/**
	 * Stringified version of this object
	 */
	@Override
	public String toString() {
		String isSuccStr = String.valueOf(isSuccessful());
		return String.format("Attempt [isSuccessful=%s, feedback=%s]", isSuccStr, getFeedback());
	}

	/**
	 * @return whether or not this command executed successfully
	 */
	public boolean isSuccessful() {
		return resultCode == RESULT_SUCCESSFUL;
	}
	
	/**
	 * @return the result code of the command associated with this Attempt
	 */
	public int getResultCode() {
		return resultCode;
	}

	/**
	 * @return the feedback received from Python after executing the command
	 */
	public String getFeedback() {
		return getFeedback(String.class);
	}

	/**
	 * @param type the class to cast the object to
	 * @return the feedback from executing the command, casted to the specified type
	 */
	public <T> T getFeedback(Class<T> type) {
		if (type == null || type.equals(String.class)) { 
			return (T) feedback;
		} else if (type.equals(Byte.class)) {
			return type.cast(Byte.valueOf(feedback));
		} else if (type.equals(Short.class)) {
			return type.cast(Short.valueOf(feedback));
		} else if (type.equals(Integer.class)) {
			return type.cast(Integer.valueOf(feedback));
		} else if (type.equals(Long.class)) {
			return type.cast(Long.valueOf(feedback));
		} else if (type.equals(Float.class)) {
			return type.cast(Float.valueOf(feedback));
		} else if (type.equals(Double.class)) {
			return type.cast(Double.valueOf(feedback));
		} else if (type.equals(Boolean.class)) {
			return type.cast(Boolean.valueOf(feedback));
		} else { // assume feedback is json
			ObjectMapper mapper = new ObjectMapper();
			try {
				return mapper.readValue(feedback, type);
			} catch (IOException e) {
				//e.printStackTrace();
			}
		}
		
		return type.cast(feedback);
	}
}
]]></Text>
		</JavaClass>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1589584967334</Id>
			<Name><![CDATA[PyException]]></Name>
			<Text><![CDATA[/**
 * Custom (generic) exception class
 */
public class PyException extends Exception { 
    public PyException(String errorMessage) {
        super(errorMessage);
    }
}]]></Text>
		</JavaClass>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1685470484366</Id>
			<Name><![CDATA[FutureAttempt]]></Name>
			<Text><![CDATA[
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.lang.Process;
import java.io.IOException;

/**
 * An implementation of `Future` for being able to query the process/status of headless or non-blocking requests to Python.
 */	
public class FutureAttempt implements Future<Attempt>{
	private final Process process;
	private boolean cancelled = false;
	
	private boolean completed = false;  // true once the process is finished and the final syserr/out has been appended
	private StringBuilder syserr = new StringBuilder(),
							sysout = new StringBuilder();
	private Attempt result = null;
	
	/**
	 * Create a FutureAttempt whose completion is based on a process running in the background.
	 * @param process Some in-progress or completed background process.
	 */
	public FutureAttempt(Process process) {
		this.process = process;
	}
	
	/**
	 * Create an already-completed FutureAttempt.
	 * This is only intended for internal Pypeline use.
	 * @param result The completed Attempt
	 */
	public FutureAttempt(Attempt result) {
		this.process = null;
		this.completed = true;
		this.result = result;
	}
	
	private void updateResult() throws IOException {
		if (completed) {
			return;
		}
		
		syserr.append(new String(process.getErrorStream().readNBytes(process.getErrorStream().available())));
		sysout.append(new String(process.getInputStream().readNBytes(process.getInputStream().available())));
		
		StringBuilder feedback = new StringBuilder();
		feedback.append(syserr).append("\n").append(sysout);
		
		result = new Attempt(
				sysout.length() > 0 || syserr.length() == 0 ? Attempt.RESULT_SUCCESSFUL : Attempt.RESULT_ERROR, 
				feedback.toString().trim()
				);
		
		if (isDone()) {
			completed = true;
		}
	}
	
	/**
	 * Retrieves the up-to-date status of the process (which may still be running).
	 * @return Attempt The current result of the process, containing the syserr and sysout up to the time of the call.
	 */
	@Override
	public Attempt get() {
		if (!completed) {
			try {
				updateResult();
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
		return result;
	}
	
	/**
	 * Waits up until the specified timeout for the process to be finished before returning the final results.
	 * @param timeout The quantity of real-time to wait
	 * @param unit The unit the timeout is in
	 * @return Attempt The result of the process, containing the syserr and sysout.
	 * @throws InterruptedException If the thread is interrupted
	 * @throws TimeoutException If the timeout elapses without the process finishing
	 */
	@Override
	public Attempt get(long timeout, TimeUnit unit) throws InterruptedException, TimeoutException {
	    if (completed || timeout <= 0) {
	    	return get();
	    }

	    boolean processCompleted;
	    try {
	        processCompleted = process.waitFor(timeout, unit);
	    } catch (InterruptedException e) {
	        cancel(true);
	        throw e;
	    }

	    if (processCompleted) {
	    	return get();
	    } else {
	        throw new TimeoutException("The operation timed out.");
	    }
    }
	
	/**
	 * Waits up until the specified timeout for the process to be finished before returning the final results.
	 * @param timeout The quantity of real-time to wait
	 * @param unit The unit the timeout is in (using the AnyLogic type for convenience)
	 * @return Attempt The result of the process, containing the syserr and sysout.
	 * @throws InterruptedException If the thread is interrupted
	 * @throws TimeoutException If the timeout elapses without the process finishing
	 */
	public Attempt get(long timeout, TimeUnits unit) throws InterruptedException, TimeoutException {
	    TimeUnit jUnit = null;
	    switch (unit) {
		    case MILLISECOND:
		    	jUnit = TimeUnit.MILLISECONDS;
		    	break;
		    case SECOND:
		    	jUnit = TimeUnit.SECONDS;
		    	break;
		    case MINUTE:
		    	jUnit = TimeUnit.MINUTES;
		    	break;
		    case HOUR:
		    	jUnit = TimeUnit.HOURS;
		    	break;
		    case DAY:
		    	jUnit = TimeUnit.DAYS;
		    	break;
		    case WEEK:
		    case MONTH:
		    case YEAR:
		    	timeout = (long)unit.convertTo(timeout*1d, DAY);
		    	jUnit = TimeUnit.DAYS;
		    	break;
	    }
	    return get(timeout, jUnit);
    }
	
	/**
	 * 
	 * @return Whether the underlying process is completed
	 */
	@Override
	public boolean isDone() {
		return !process.isAlive();
	}
	
	/**
	 * 
	 * @param mayInterruptIfRunning Whether the process can be force-quit if it's still in progress
	 * @return Whether the process was interrupted
	 */
	@Override
	public boolean cancel(boolean mayInterruptIfRunning) {
		if (mayInterruptIfRunning) {
			process.destroy();
			cancelled = true;
		}
		return cancelled;
	}
	
	/**
	 * @return Whether the processes was force-quit (e.g., from the user calling `cancel(true)` or the thread being interrupted from `get(timeout,...)`
	 */
	@Override
	public boolean isCancelled() {
		return cancelled;
	}
}]]></Text>
		</JavaClass>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1665787875730</Id>
			<Name><![CDATA[CustomAnnotationIntrospector]]></Name>
			<Text><![CDATA[import com.fasterxml.jackson.databind.introspect.JacksonAnnotationIntrospector;

import com.fasterxml.jackson.databind.introspect.Annotated;
import com.fasterxml.jackson.databind.type.TypeFactory;

import com.fasterxml.jackson.databind.introspect.AnnotatedMember;



/**
 * CustomAnnotationIntrospector
 */	
public class CustomAnnotationIntrospector extends JacksonAnnotationIntrospector implements Serializable {

	private final JsonFilter filter;

    /**
     * Default constructor
     */
    public CustomAnnotationIntrospector() {
    	filter = null;
    }

    /**
     * Constructor initializing the fields
     */
    public CustomAnnotationIntrospector(JsonFilter filter) {
		this.filter = filter;
    }
    
    @Override
    public boolean hasIgnoreMarker(AnnotatedMember a) {
    	if (super.hasIgnoreMarker(a))
    		return true;
    	if (filter == null)
    		return false;
    	return a.getAnnotation(AnyLogicInternalCodegenAPI.class) != null;
    }
    
    @Override
    protected boolean _isIgnorable(Annotated a) {
    	if (super._isIgnorable(a))
    		return true;
    	if (filter == null)
    		return false;
    	return filter.skipJsonifying(a.getRawType());
    }

	/**
	 * This number is here for model snapshot storing purpose
	 * It needs to be changed when this class gets changed
	 */ 
	private static final long serialVersionUID = 1L;

}]]></Text>
		</JavaClass>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1665787888479</Id>
			<Name><![CDATA[JsonFilter]]></Name>
			<Text><![CDATA[import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.introspect.JacksonAnnotationIntrospector;
import com.fasterxml.jackson.databind.introspect.Annotated;
import com.fasterxml.jackson.databind.type.TypeFactory;
import java.lang.reflect.Modifier;
import java.lang.reflect.Field;


/**
 * A custom filter used when converting Java/AnyLogic objects to JSON.
 * It can also work in a blacklist mode (default) or a whitelist mode:
 * 	In blacklist mode, **including** an object to it will **exclude** it from the output.
 * 	In whitelist mode, it will prevent all objects from outputted **except** for what's included in the filter.
 * There are three possible ways to reference object - by class, package, or name.
 * 	Both modes operate based on an 'OR' condition, meaning you only have to specify one way and it will be applied.
 */	
public class JsonFilter {
	private ObjectMapper parent;
	
	/**
	 * A reference for whether whether autogenerated objects are included when in **blacklist** mode.
	 */
	public final static boolean defaultBlacklistAutogeneratedSetting = true;
	
	/**
	 * A reference for what classes are included in this class's usage of "default classes" when in **blacklist** mode.
	 */
	public final static HashSet<Class<?>> defaultBlacklistedClasses = new HashSet<>(Arrays.asList(
			Color.class,
			Font.class,
			Shape.class,
			EventOriginator.class,
			IStatechartState.class,
			AbstractLinkToAgent.class,
			Scale.class,
			CustomDistribution.class,
			Random.class,
			Histogram.Appearance.class,
			Histogram2D.Appearance.class,
			Chart2DPlot.Appearance.class,
			SDIntegrationManager.class,
			LinkToAgentAnimationSettings.class,
			Port.class
			));
	
	/**
	 * A reference for what packages are included in this class's usage of "default packages" when in **blacklist** mode.
	 */
	public final static HashSet<String> defaultBlacklistedPackages = new HashSet<>(Arrays.asList(
		"com.anylogic.libraries.pypeline",
		"anylogic_jsonifier_library",
		"com.anylogic.libraries.processmodeling",
		"com.anylogic.libraries.material_handling",
		"com.anylogic.libraries.pedestrian",
		"com.anylogic.libraries.rail",
		"com.anylogic.libraries.road",
		"com.anylogic.libraries.fluid",
		"com.anylogic.engine.markup",
		"com.anylogic.engine.connectivity",
		"com.anylogic.engine.presentation"
		));
	
	/**
	 * A reference for what packages are included in this class's usage of "default names" when in **blacklist** mode.
	 */
	public final static HashSet<String> defaultBlacklistedNames = new HashSet<>(Arrays.asList(
			".+_xjal",
			"serialVersionUID"
		));
	
	/**
	 * A reference for whether whether autogenerated objects are included when in **whitelist** mode.
	 */
	public final static boolean defaultWhitelistAutogeneratedSetting = false;
	
	/**
	 * A reference for what classes are included in this class's usage of "default classes" when in **whitelist** mode.
	 */
	public final static HashSet<Class<?>> defaultWhitelistedClasses = new HashSet<>(Arrays.asList(
			Number.class,
			Boolean.class,
			Agent.class,
			AgentList.class,
			ChartItem.class,
			DataItem.class,
			DataSet.class,
			HistogramData.class,
			StatisticsContinuous.class,
			StatisticsDiscrete.class
			));
	
	/**
	 * A reference for what packages are included in this class's usage of "default packages" when in **whitelist** mode.
	 */
	public final static HashSet<String> defaultWhitelistedPackages = new HashSet<>(Arrays.asList(
			"java.util",
			"java.lang"
			
		));
	
	/**
	 * A reference for what packages are included in this class's usage of "default names" when in **whitelist** mode.
	 */
	public final static HashSet<String> defaultWhitelistedNames = new HashSet<>(Arrays.asList(
			
		));
	
	
	/**
	 * The active set of classes to consider in JSON-conversion.
	 */
	private HashSet<Class<?>> includedClasses = new HashSet<>();
	
	/**
	 * The active set of packages for which classes directly in the package are considered in JSON-conversion.
	 */
	private HashSet<String> includedPackages = new HashSet<>();
	
	/**
	 * The active set of object names (parsed as regex patterns) to consider in JSON-conversion.
	 */
	private HashSet<String> includedNames = new HashSet<>();
	
	/**
	 * Whether to include autogenerated objects
	 */
	private boolean includeAutogeneratedObjects = false;
	
	/**
	 * Whether the filtering is operating in blacklist mode (included => won't be outputted) or whitelist mode (included => only will be outputted)
	 */
	private boolean inBlacklistMode = true;
	
	
	/**
	 * Create a new filter object in blacklist mode with the default set of names/classes/packages.
	 */
	public JsonFilter(ObjectMapper parentMapper) {
		// TODO should throw an error if parent mapper is null?
		this(parentMapper, true);
	}
	
	/**
	 * Create a new filter object in blacklist mode.
	 * @param parentMapper A reference to the object mapper this filter should apply to
	 * @param loadDefault Whether to load the default set of classes + packages
	 */
	public JsonFilter(ObjectMapper parentMapper, boolean loadDefault) {
		this(parentMapper, true, loadDefault);
	}
	
	/**
	 * Create a new filter object.
	 * @param parentMapper A reference to the object mapper this filter should apply to
	 * @param inBlacklistMode Whether to set the filter in blacklist mode (vs whitelist mode)
	 * @param loadDefault Whether to load the default set of classes + packages
	 */
	public JsonFilter(ObjectMapper parentMapper, boolean inBlacklistMode, boolean loadDefault) {
		this.parent = parentMapper;
		this.inBlacklistMode = inBlacklistMode;
		this.includeAutogeneratedObjects = inBlacklistMode ? defaultBlacklistAutogeneratedSetting : defaultWhitelistAutogeneratedSetting;
		if (loadDefault) {
			resetNames();
			resetClasses();
			resetPackages();
		}
	}
	
	/**
	 * Create a new filter object with specific initial values
	 * @param parentMapper A reference to the object mapper this filter should apply to
	 * @param inBlacklistMode Whether to set the filter in blacklist mode (vs whitelist mode)
	 * @param includeAutogenerateds Whether autogenerated objects are included in the filter
	 * @param includedPackages The list of packages to initially have included; if null, will start with a cleared set
	 * @param includedClasses The list of classes to initially have included; if null, will start with a cleared set
	 * @param includedNames The list of names to initially have included; if null, will start with a cleared set
	 */
	public JsonFilter(ObjectMapper parentMapper, boolean inBlacklistMode, boolean includeAutogenerateds, String[] includedPackages, Class<?>[] includedClasses, String[] includedNames) {
		this.parent = parentMapper;
		this.inBlacklistMode = inBlacklistMode;
		this.includeAutogeneratedObjects = includeAutogenerateds;
		if (includedPackages == null)
			clearPackages();
		else
			includePackages(includedPackages);
		
		if (includedClasses == null)
			clearClasses();
		else
			includeClasses(includedClasses);
		
		if (includedNames == null)
			clearNames();
		else
			includeNames(includedNames);
	}
	
	/**
	 * Determine if the given info seems to be an autogenerated object.
	 * Both arguments are optional (may be null)
	 * @param name
	 * @param clazz
	 * @return
	 */
	private static boolean looksAutogenerated(String name, int modifiers, Class<?> clazz) {
		// [notes]
		// _ds_* == only datasets
		// *_xjal == can be HyperArrays, Level[], Agent types, SDIntegrationManager, Map, EventTimeout; sometimes protected and static
		// __* == seem to be all protected and static, but any types (even common like double)
		// _* = protected static ints
		// any vars with the @AnyLogicInternalCodegenAPI annotation -- BUT DOESNT HAVE RETENTION SO IS ERASED ON RUNTIME
		// _origin_VA
		
		if (name != null) {
			// if class is not provided, assume all _ds_* names are generated
			if (name.startsWith("_ds_") && (clazz == null || DataSet.class.isAssignableFrom(clazz))) {
				return true;
			}
	
			// no class info is considered, as it can be too many types
		    if (name.endsWith("_xjal")) {
		    	return true;
		    }
		    
		    // fixed name of autogen'd view area (even though it likely can't/won't be serialized)
		    if (name.equals("_origin_VA")) {
		    	return true;
		    }
		}
		
		if (clazz != null) {
		    // check for _* or __* objects that are protected and static 
		    if (name != null && name.startsWith("_") && Modifier.isProtected(modifiers) && Modifier.isStatic(modifiers)) {
		    	return true;
		    }
		}
		
	    return false;
	}
	
	/**
	 * Determines whether a field should be omitted from being converted to JSON, based on info about it.
	 * To qualify based on the name is based on regex pattern matching.
	 * To qualify for being "inside" the package, the exact class must be inside the package.
	 * To qualify for being a class, the class must be assignable from the one in the filter
	 * 		(i.e., it can either be the same class as the one in the filter or a child class of it).
	 * 
	 * @param name The name of the object; null=skipped
	 * @param modifiers The object modifiers; 1=skipped/just public
	 * @param clazz The class of the object; null=skipped
	 * @return true if the provided field should not be included in the outputted JSON
	 */
	public boolean skipJsonifying(String name, int modifiers, Class<?> clazz) {
		boolean skip = false; // store in a variable since generated-checked should be applied first, and possibly overridden by the following checks
		if (looksAutogenerated(name, modifiers, clazz)) {
			// skip when (included and blacklist) or (not included and not blacklist/whitelist)
			skip = inBlacklistMode == includeAutogeneratedObjects;
		}
		
		// for blacklist mode, can immediate consider it skippable if ANY of the conditions are met
		boolean nameIncluded = name != null && includedNames.stream().anyMatch(n -> name.matches(n));
		if (inBlacklistMode && nameIncluded) {
			skip = true;
		}
		boolean clsIncluded = clazz != null && includedClasses.stream().anyMatch(c -> c.isAssignableFrom(clazz));
		if (inBlacklistMode && clsIncluded) {
			skip = true;
		}
		boolean pkgIncluded = clazz != null && includedPackages.contains(clazz.getPackageName());
		if (inBlacklistMode && pkgIncluded) {
			skip = true;
		}
		
		// for whitelist mode, ALL the conditions need to fail to be skipped
		if (!inBlacklistMode && !nameIncluded && !clsIncluded && !pkgIncluded) {
			skip = true;
		}
		
		// otherwise, assume it should be OK to include
		return skip;
	}
	
	/**
	 * Determines whether a field should be omitted from being converted to JSON, based on just an object's name.
	 * To qualify based on the name is based on regex pattern matching.
	 * @param name The name of the object; assumed to be non-null
	 * @return true if the provided field should not be included in the outputted JSON
	 */
	public boolean skipJsonifying(String name) {
		return skipJsonifying(name, 1, null);
	}
	
	/**
	 * Determines whether a field should be omitted from being converted to JSON, based on the object's class and package name.
	 * To qualify for being a class, the class must be assignable from the one in the filter
	 * 		(i.e., it can either be the same class as the one in the filter or a child class of it).
	 * To qualify for being "inside" the package, the exact class must be inside the package.
	 * @param clazz The class of the object; assumed to be non-null
	 * @return true if the provided field should not be included in the outputted JSON
	 */
	public boolean skipJsonifying(Class<?> clazz) {
		return skipJsonifying(null, 1, clazz);
	}
	
	/**
	 * Get a report of everything that will/won't be skipped in the given object.
	 * @param obj
	 * @return
	 */
	public Map<Pair<String,Class<?>>,Boolean> skipJsonifyingReport(Object obj) {
		Map<Pair<String,Class<?>>,Boolean> report = new HashMap<>();
		for (Field f : obj.getClass().getDeclaredFields()) {
			String name = f.getName();
			Class<?> cls = f.getType();
			report.put(new Pair<>(name, cls), skipJsonifying(name, f.getModifiers(), cls));
		}
		return report;
	}
	
	/**
	 * Gets the packages whose packages are included in the filter.
	 * When in blacklist mode (default), these will be skipped in the JSON conversion; in whitelist mode, only these will be included.
	 * @return a copy of the set of fully qualified package names
	 */
	public HashSet<String> getIncludedPackages() {
		return new HashSet<>(includedPackages);
	}
	
	/**
	 * Gets the classes that are included in the filter.
	 * When in blacklist mode (default), these will be skipped in the JSON conversion; in whitelist mode, only these will be included.
	 * Any subclasses will also be included (e.g., if `Shape.class` is included, `ShapeCAD.class` will be considered included as well).
	 * @return a copy of the set of classes
	 */
	public HashSet<Class<?>> getIncludedClasses() {
		return new HashSet<>(includedClasses);
	}
	
	/**
	 * Gets the name patterns who are included in the filter.
	 * When in blacklist mode (default), these will be skipped in the JSON conversion; in whitelist mode, only these will be included.
	 * @return a copy of the set of names, as regex patterns
	 */
	public HashSet<String> getIncludedNames() {
		return new HashSet<>(includedNames);
	}
	
	/**
	 * Various objects are auto-generated and added to your model by AnyLogic in response to certain user-defined objects/properties.
	 * See `setAutogeneratedInclusion` for an example.
	 * 
	 * @return Whether auto-generated objects are included in the outputted JSON
	 */
	public boolean isAutogeneratedIncluded() {
		return this.includeAutogeneratedObjects;
	}
	
	/**
	 * 
	 * @return Whether the filter is currently in blacklist mode (no objects except those included will be outputted)
	 */
	public boolean isInBlacklistMode() {
		return this.inBlacklistMode;
	}
	
	/**
	 * @return Whether the filter is currently in whitelist mode (only included objects will be outputted)
	 */
	public boolean isInWhitelistMode() {
		return !this.inBlacklistMode;
	}
	
	/**
	 * Update the mode of this object (i.e., blacklist or whitelist).
	 * If the mode is being toggled, the previous classes/names/packages will be cleared and defaults for the new mode loaded in, otherwise nothing will happen.
	 * @param inBlacklist Whether to set the filter to be in blacklist mode (vs in whitelist)
	 * @return a reference to this object
	 */
	public JsonFilter setMode(boolean inBlacklist) {
		return setMode(inBlacklist, true);
	}
	
	/**
	 * Update the mode of this object (i.e., blacklist or whitelist).
	 * Nothing will be changed if attempting to set it in the mode it's already in.
	 * @param inBlacklist Whether to set the filter to be in blacklist mode (vs in whitelist)
	 * @param loadDefault Whether to reset packages/classes/names/autogen to their default (vs just clear/leave-autogen-alone)
	 * @return a reference to this object
	 */
	public JsonFilter setMode(boolean inBlacklist, boolean loadDefault) {
		// do nothing if setting in the already existing mode
		if (this.inBlacklistMode == inBlacklist) 
			return this;

		this.inBlacklistMode = inBlacklist;
		if (loadDefault) {
			return resetAll();
		} else  {
			return clearAll();
		}
	}
	
	
	/**
	 * Various objects are auto-generated and added to your model by AnyLogic in response to certain user-defined objects/properties.
	 * For example, adding a Plot object with 3 lines set to the 'Value' type (i.e., not referencing a defined dataset)
	 * 		will autogenerate 3 DataSets with the name structure `_X_expressionN_dataSet_xjal`,
	 * 		where 'X' is the name of the plot and N is a number between 0 and 2 (for each of the 3 lines).
	 * This method lets you set whether you want to include those objects in the filter.
	 * When in blacklist mode, these will be skipped in the JSON output; in whitelist mode, these will be allowed.
	 * Calling this function with the same value multiple times will have no extra effect.
	 * @param include Whether to include autogenerated objects
	 * @return a reference to this object
	 */
	public JsonFilter setAutogenerated(boolean include) {
		if (includeAutogeneratedObjects == include)
			return this;
		includeAutogeneratedObjects = include;
		return this.update();
	}
	
	/**
	 * Various objects are auto-generated and added to your model by AnyLogic in response to certain user-defined objects/properties.
	 * For example, adding a Plot object with 3 lines set to the 'Value' type (i.e., not referencing a defined dataset)
	 * 		will autogenerate 3 DataSets with the name structure `_X_expressionN_dataSet_xjal`,
	 * 		where 'X' is the name of the plot and N is a number between 0 and 2 (for each of the 3 lines).
	 * This method includes autogenerated objects in the filter (in blacklist mode, will not be in the output; in whitelist mode, will be allowed).
	 * @return a reference to this object
	 */
	public JsonFilter includeAutogenerated() {
		return setAutogenerated(true);
	}
	
	/**
	 * Includes the provided package(s) in the filter.
	 * When in blacklist mode (default), these will be skipped in the JSON conversion; in whitelist mode, only these will be included.
	 * Calling this function with the same value multiple times will have no extra effect.
	 * Note: subpackages are not considered.
	 * @param pkgs One or more fully qualified package name
	 * @return a reference to this object
	 */
	public JsonFilter includePackages(String... pkgs) {
		for (String pkg : pkgs)
			includedPackages.add(pkg);
		return this.update();
	}
	
	/**
	 * Includes the provided classes(s) in the filter.
	 * When in blacklist mode (default), these will be skipped in the JSON conversion; in whitelist mode, only these will be included.
	 * Calling this function with the same value multiple times will have no extra effect.
	 * @param classes One or more classes
	 * @return a reference to this object
	 */
	public JsonFilter includeClasses(Class<?>... classes) {
		for (Class<?> cls : classes)
			includedClasses.add(cls);
		return this.update();
	}
	
	/**
	 * Includes the provided names in the filter.
	 * When in blacklist mode (default), these will be skipped in the JSON conversion; in whitelist mode, only these will be included.
	 * Calling this function with the same value multiple times will have no extra effect.
	 * @param names One or more regex patterns
	 * @return a reference to this object
	 */
	public JsonFilter includeNames(String... names) {
		for (String name : names)
			includedNames.add(name);
		return this.update();
	}
	
	/**
	 * Various objects are auto-generated and added to your model by AnyLogic in response to certain user-defined objects/properties.
	 * For example, adding a Plot object with 3 lines set to the 'Value' type (i.e., not referencing a defined dataset)
	 * 		will autogenerate 3 DataSets with the name structure `_X_expressionN_dataSet_xjal`,
	 * 		where 'X' is the name of the plot and N is a number between 0 and 2 (for each of the 3 lines).
	 * This method excludes autogenerated objects in the filter (in blacklist mode, will be allowed in the output; in whitelist mode, will not be in the output).
	 * @return a reference to this object
	 */
	public JsonFilter excludeAutogenerated() {
		return setAutogenerated(false);
	}
	
	/**
	 * Excludes the provided package(s) from the filter.
	 * When in blacklist mode (default), these will be allowed in the JSON conversion; in whitelist mode, these will be prevented.
	 * Calling this function with the same value multiple times will have no extra effect.
	 * @param pkgs One or more fully qualified package name
	 * @return a reference to this object
	 */
	public JsonFilter excludePackages(String... pkgs) {
		for (String pkg : pkgs)
			includedPackages.remove(pkg);
		return this.update();
	}
	
	/**
	 * Excludes the provided classes(s) in the filter.
	 * When in blacklist mode (default), these will be allowed in the JSON conversion; in whitelist mode, these will be prevented.
	 * Calling this function with the same value multiple times will have no extra effect.
	 * @param classes One or more classes
	 * @return a reference to this object
	 */
	public JsonFilter excludeClasses(Class<?>... classes) {
		for (Class<?> cls : classes)
			includedClasses.remove(cls);
		return this.update();
	}
	
	/**
	 * Excludes the provided names(s) from the filter.
	 * When in blacklist mode (default), these will be allowed in the JSON conversion; in whitelist mode, these will be prevented.
	 * Calling this function with the same value multiple times will have no extra effect.
	 * @param names One or more regex patterns
	 * @return a reference to this object
	 */
	public JsonFilter excludeNames(String... names) {
		for (String name : names)
			includedNames.remove(name);
		return this.update();
	}
	
	/**
	 * Removes all packages from the current filter.
	 * When in blacklist mode (default), this will allow ALL packages; in whitelist mode, this will prevent ALL packages.
	 * This is *NOT* reccomended for blacklist mode (without further intervention), as many AnyLogic objects are not configured to be JSON-serializable.
	 * @return a reference to this object
	 */
	public JsonFilter clearPackages() {
		includedPackages.clear();
		return this.update();
	}
	
	/**
	 * Removes all classes from the current filter.
	 * When in blacklist mode (default), this will allow ALL classes; in whitelist mode, this will prevent ALL classes.
	 * This is *NOT* reccomended for blacklist mode (without further intervention), as many AnyLogic objects are not configured to be JSON-serializable.
	 * @return a reference to this object
	 */
	public JsonFilter clearClasses() {
		includedClasses.clear();
		return this.update();
	}
	
	/**
	 * Removes all names from the current filter.
	 * When in blacklist mode (default), this will allow ALL names; in whitelist mode, this will prevent ALL names.
	 * This is *NOT* reccomended for blacklist mode (without further intervention), as many AnyLogic objects are not configured to be JSON-serializable.
	 * @return a reference to this object
	 */
	public JsonFilter clearNames() {
		includedNames.clear();
		return this.update();
	}
	
	/**
	 * Removes all packages, classes, and names from the current filter.
	 * When in blacklist mode (default), this will allow ALL objects; in whitelist mode, this will prevent ALL objects.
	 * This is *NOT* reccomended for blacklist mode (without further intervention), as many AnyLogic objects are not configured to be JSON-serializable.
	 * @return a reference to this object
	 */
	public JsonFilter clearAll() {
		includedPackages.clear();
		includedClasses.clear();
		includedNames.clear();
		return this.update();
	}
	
	/**
	 * Resets the autogenerated setting to its default value, based on the mode.
	 * @return a reference to this object
	 */
	public JsonFilter resetAutogenerated() {
		boolean include = isInBlacklistMode() ? defaultBlacklistAutogeneratedSetting : defaultWhitelistAutogeneratedSetting;
		return setAutogenerated(include);
	}
	
	/**
	 * Resets the set of packages, reverting to the default set.
	 * @return a reference to this object
	 */
	public JsonFilter resetPackages() {
		clearPackages();
		if (inBlacklistMode) {
			for (String p : defaultBlacklistedPackages)
				includedPackages.add(p);
		} else {
			for (String p : defaultWhitelistedPackages)
				includedPackages.add(p);
		}
		return this.update();
	}
	
	/**
	 * Resets the set of classes, reverting to the default set.
	 * @return a reference to this object
	 */
	public JsonFilter resetClasses() {
		clearClasses();
		if (inBlacklistMode) {
			for (Class<?> c : defaultBlacklistedClasses)
				includedClasses.add(c);
		} else {
			for (Class<?> c : defaultWhitelistedClasses)
				includedClasses.add(c);
		}
		return this.update();
	}
	
	/**
	 * Resets the set of names, reverted to the default set.
	 * @return a reference to this object
	 */
	public JsonFilter resetNames() {
		clearNames();
		if (inBlacklistMode) {
			for (String n : defaultBlacklistedNames)
				includedNames.add(n);
		} else {
			for (String n : defaultWhitelistedNames)
				includedNames.add(n);
		}
		return this.update();
	}
	
	/**
	 * Resets the set of packages, classes, and names to the default sets and the autogenerated setting to its default (based on the mode).
	 * @return a reference to this object
	 */
	public JsonFilter resetAll() {
		return resetAutogenerated().resetPackages().resetClasses().resetNames();
	}
	
	private JsonFilter update() {
		// TODO - do you need to create a new one each time?
		// TODO - confirm this works as expected
		parent.setAnnotationIntrospector(new CustomAnnotationIntrospector(this));
		return this;
	}
	

	@Override
	public String toString() {
		return String.format("JsonFilter[%s | %s autogen, %s names, %s classes, %s packages]", inBlacklistMode ? "BLACK": "WHITE", includeAutogeneratedObjects ? "YES":"NO", includedNames.size(), includedClasses.size(), includedPackages.size());
	}

}]]></Text>
		</JavaClass>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1678394437727</Id>
			<Name><![CDATA[Serializers]]></Name>
			<Text><![CDATA[import java.io.IOException;
import com.fasterxml.jackson.databind.ser.std.StdSerializer;
import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.JsonSerializer;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.databind.SerializerProvider;
import java.util.stream.IntStream;
import java.util.stream.Collectors;
import java.util.regex.Pattern;
import java.lang.reflect.Field;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Modifier;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.querydsl.sql.ColumnMetadata;
import com.querydsl.core.types.PathMetadata;
import com.querydsl.core.Tuple;
import com.querydsl.core.types.Expression;
import com.querydsl.core.types.Path;
import com.querydsl.sql.ForeignKey;
import com.querydsl.sql.PrimaryKey;
import com.querydsl.sql.RelationalPathBase;

/**
 * Container class for all serializers.
 * Technical notes: - Contains one base class (ACustomSerializer) intended to have the proper constructors and initial methods.
 * 					- All other classes extend this for each class it wants to serialize for.
 * 						they need to implement the empty constructor calling `super(Classname.class)` and the abstract function.
 * 					- Use this class's `register` function to add the classes to the provided ObjectMapper
 * 					- Note: Jackson will use whatever class matches the lowest level class, 
 * 						enabling simple parent class serializers and more useful/specific child class serializers.
 */
public class Serializers {
	
	public static void register(ObjectMapper mapper, Class<?>... serClasses) {
		SimpleModule module = new SimpleModule();
		for (Class<?> c : serClasses) {
			try {
				ACustomSerializer s = (ACustomSerializer)c.getDeclaredConstructor().newInstance();
				module.addSerializer(s.handledType(), s);
			} catch (Exception e) {
				e.printStackTrace();
			}
		}
		mapper.registerModule(module);
	}
	
	public abstract static class ACustomSerializer<T> extends StdSerializer<T> {
		public ACustomSerializer() {
			this(null);
		}
		
		public ACustomSerializer(Class<T> t) {
			super(t);
		}
		
		public abstract void serialize(T value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonProcessingException;
	}
	
	public static class DataSetSerializer extends ACustomSerializer<DataSet> {
		
		public DataSetSerializer() {
			super(DataSet.class);
		}

	    @Override
	    public void serialize(
	      DataSet value, JsonGenerator jgen, SerializerProvider provider) 
	      throws IOException, JsonProcessingException {
	        jgen.writeStartObject();
	        jgen.writeNumberField("xmin", value.getXMin());
	        jgen.writeNumberField("xmean", value.getXMean());
	        jgen.writeNumberField("xmedian", value.getXMedian());
	        jgen.writeNumberField("xmax", value.getXMax());
	        jgen.writeNumberField("ymin", value.getYMin());
	        jgen.writeNumberField("ymean", value.getYMean());
	        jgen.writeNumberField("ymedian", value.getYMedian());
	        jgen.writeNumberField("ymax", value.getYMax());
	        // need to recreate entire plain data table, as the default serializer cuts off with a certain limit. 
	        // i.e., without this, it would look like: "plainDataTable" : [ [ 0.0, 5.0 ], [ 1.0, 5.0 ], [ 2.0, 5.0 ], ..., [ 999.0, 4.0 ], [ "... 1361 more items" ]
	        List<double[]> values = new ArrayList<>();
	    	IntStream.range(0, value.size()).forEach(i -> values.add(new double[]{value.getX(i), value.getY(i)}));
	        jgen.writeObjectField("plainDataTable", value.getPlainDataTable());
	        jgen.writeEndObject();
	    }
	}
	
	public static class Histogram1DSerializer extends ACustomSerializer<HistogramData> {
		
		public Histogram1DSerializer() {
			super(HistogramData.class);
		}
		
	    @Override
	    public void serialize(
	    		HistogramData value, JsonGenerator jgen, SerializerProvider provider) 
	      throws IOException, JsonProcessingException {
	        jgen.writeStartObject();
	        int count = value.count();
	        jgen.writeNumberField("count", count);
	        // Follow similar structure as in ALCloud: User can derive ranges based on min X and interval width
	        jgen.writeNumberField("lowerBound", value.getXMin());
	        jgen.writeNumberField("intervalWidth", value.getIntervalWidth());
	        int[] hits = IntStream.range(0, value.getNumberOfIntervals())
	        		.map(i -> Math.round((float)value.getPDF(i)*count)).toArray();
	        jgen.writeObjectField("hits", hits);
	        // HSimpleData = User set explicit min/max. There may be data outside this range, so add counts of lower/upper range of interval
	        if (value instanceof HistogramSimpleData) {
	        	HistogramSimpleData hdataSimple = (HistogramSimpleData) value;
	        	jgen.writeNumberField("hitsOutLow", Math.round((float)hdataSimple.getPDFOutsideLow()*count));
	        	jgen.writeNumberField("hitsOutHigh", Math.round((float)hdataSimple.getPDFOutsideHigh()*count));
	        }
	        // Add in other useful stats available from histogram
	        HashMap<String, Double> dtableStats = new HashMap<>();
	        dtableStats.put("min", value.min());
	        dtableStats.put("max", value.max());
	        dtableStats.put("mean", value.mean());
	        dtableStats.put("deviation", value.deviation());
	        jgen.writeObjectField("statistics", dtableStats);
	        jgen.writeEndObject();
	    }
	}
	
	public static class Histogram2DSerializer extends ACustomSerializer<Histogram2DData> {
		
		public Histogram2DSerializer() {
			super(Histogram2DData.class);
		}
		
	    @Override
	    public void serialize(
	    		Histogram2DData value, JsonGenerator jgen, SerializerProvider provider) 
	      throws IOException, JsonProcessingException {
	        jgen.writeStartObject();
	        // Follow similar structure as in ALCloud; user can derive interval size, etc. from available data
	        int nX = value.getNumberOfXIntervals();
	        int nY = value.getNumberOfYIntervals();
	        int[][] hits = new int[nY][nX];
	        int[] hitsOutLow = new int[nX];
	        int[] hitsOutHigh = new int[nX];
	        for (int x = 0; x < nX; x++) {
	        	int xcount = value.count(x);
	        	hitsOutLow[x] = Math.round((float)value.getPDFOutsideLow(x)*xcount);
	        	hitsOutHigh[x] = Math.round((float)value.getPDFOutsideHigh(x)*xcount);
	        	for (int y = 0; y < nY; y++) {
	        		hits[y][x] = Math.round((float)value.getPDF(x, y)*xcount);
	        	}
	        }
	        jgen.writeObjectField("hits", hits);
	        jgen.writeObjectField("hitsOutLow", hitsOutLow);
	        jgen.writeObjectField("hitsOutHigh", hitsOutHigh);
	        jgen.writeNumberField("xMin", value.getXMin());
	        jgen.writeNumberField("xMax", value.getXMax());
	        jgen.writeNumberField("yMin", value.getYMin());
	        jgen.writeNumberField("yMax", value.getYMax());
	        jgen.writeEndObject();
	    }
	}
	
	public static class StatisticsDiscreteSerializer extends ACustomSerializer<StatisticsDiscrete> {
		
		public StatisticsDiscreteSerializer() {
			super(StatisticsDiscrete.class);
		}
		
	    @Override
	    public void serialize(
	    		StatisticsDiscrete value, JsonGenerator jgen, SerializerProvider provider) 
	      throws IOException, JsonProcessingException {
	        jgen.writeStartObject();
	        String[] statRows = value.toString().split("\n");
	    	Arrays.stream(statRows)
	    		.map(s -> s.strip().split("\t"))
	    		.forEach(s -> {try {
	    			jgen.writeNumberField(s[0], Double.valueOf(s[1].replaceAll(",", "")));
	    		} catch (IOException e) {}});
	        jgen.writeEndObject();
	    }
	}
	
	public static class StatisticsContinuousSerializer extends ACustomSerializer<StatisticsContinuous> {
		
		public StatisticsContinuousSerializer() {
			super(StatisticsContinuous.class);
		}
		
	    @Override
	    public void serialize(
	    		StatisticsContinuous value, JsonGenerator jgen, SerializerProvider provider) 
	      throws IOException, JsonProcessingException {
	        jgen.writeStartObject();
	        String[] statRows = value.toString().split("\n");
	    	Arrays.stream(statRows)
	    		.map(s -> s.strip().split("\t"))
	    		.forEach(s -> {try {
	    			jgen.writeNumberField(s[0], Double.valueOf(s[1].replaceAll(",", "")));
	    		} catch (IOException e) {}});
	        jgen.writeEndObject();
	    }
	}
	
	/**
	 * Parent class of Transitions, Events, and DyanmicEvents.
	 * Technical note: needed due to recursive issue from `getAgent`
	 */
	public static class EventOriginatorSerializer extends ACustomSerializer<EventOriginator> {
		
		public EventOriginatorSerializer() {
			super(EventOriginator.class);
		}
		
	    @Override
	    public void serialize(
	    		EventOriginator value, JsonGenerator jgen, SerializerProvider provider) 
	      throws IOException, JsonProcessingException {
	        jgen.writeStartObject();
	        jgen.writeNumberField("time_remaining", value.getRest());
	        jgen.writeEndObject();
	    }
	}
	
	public static class StatechartSerializer extends ACustomSerializer<Statechart> {
		
		public StatechartSerializer() {
			super(Statechart.class);
		}
		
	    @Override
	    public void serialize(
	    		Statechart value, JsonGenerator jgen, SerializerProvider provider) 
	      throws IOException, JsonProcessingException {
	        jgen.writeStartObject();
	        jgen.writeObjectField("active_state", Map.of("full", value.getFullState(), "simple", value.getActiveSimpleState().name()));
	        jgen.writeEndObject();
	    }
	}
	
	public static class FlowchartBlockSerializer extends ACustomSerializer<FlowchartBlock> {
		
		public FlowchartBlockSerializer() {
			super(FlowchartBlock.class);
		}
		
		@Override
	    public void serialize(
	    		FlowchartBlock value, JsonGenerator jgen, SerializerProvider provider) 
	      throws IOException, JsonProcessingException {
			jgen.writeStartObject();
			// idk y but some block's type are inner classes, so are shown as "<user_model_package>.<AgentType>$<number>" (e.g., mymodel.Main$1)
			// 	and in these cases, the simple name is empty...
			// The toString of built-in blocks seem to reliably have the type in the toString, so use that in these cases.	
	        jgen.writeStringField("type", value.getClass().getSimpleName().isEmpty()
							? Pattern.compile("[^:]+:\\s*(.*?)\\s.+", Pattern.DOTALL).matcher(value.toString()).replaceFirst("$1")
							: value.getClass().getSimpleName());
	        jgen.writeObjectField("parameters",
	        		// wonky collection is to allow non-null values
	        		Arrays.stream(value.getParameterNames()).collect(HashMap::new, (map,name)->map.put(name, value.getParameter(name)), HashMap::putAll)
	        );
	        jgen.writeObjectField("ports",
	        		// xjal check in filter omits internal ports used in messaging
	        		Arrays.stream(value.getClass().getFields()).filter(f -> !f.getName().endsWith("_xjal") && f.getType().isAssignableFrom(FlowchartMappedPort.class))
		        	.collect(
			        		Collectors.toMap(f -> f.getName(), f -> {try { return ((FlowchartMappedPort)f.get(value)).count(); } catch (Exception e) {return -1;}})
			        		)
	        );
	        jgen.writeEndObject();
	    }
	}
	
	public static class AgentSerializer extends ACustomSerializer<Agent> {
		
		public AgentSerializer() {
			super(Agent.class);
		}
		
		@Override
	    public void serialize(
	    		Agent value, JsonGenerator jgen, SerializerProvider provider) 
	      throws IOException, JsonProcessingException {
			jgen.writeStartObject();
			HashMap<String, Object> map = Jsonifier.agentToMap(value, true, null);
			for (String key : new TreeSet<>(map.keySet())) {
				Object val = map.get(key);
				jgen.writeObjectField(key, val);
			}
			jgen.writeEndObject();
		}
	}
	
	public static class AgentListSerializer extends ACustomSerializer<AgentList> {
		
		public AgentListSerializer() {
			super(AgentList.class);
		}
		
		@Override
	    public void serialize(
	    		AgentList value, JsonGenerator jgen, SerializerProvider provider) 
	      throws IOException, JsonProcessingException {
			jgen.writeStartArray();
			for (int i = 0; i < value.size(); i++) {
				jgen.writeObject(value.get(i));
			}
			jgen.writeEndArray();
		}
	}
	
	public static class ViewAreaSerializer extends ACustomSerializer<ViewArea> {
		
		public ViewAreaSerializer() {
			super(ViewArea.class);
		}
		
		@Override
	    public void serialize(
	    		ViewArea value, JsonGenerator jgen, SerializerProvider provider) 
	      throws IOException, JsonProcessingException {
			jgen.writeNull();
		}
	}
	
	public static class LinkToAgentsSerializer extends ACustomSerializer<LinkToAgentStandardImpl> {
		
		public LinkToAgentsSerializer() {
			super(LinkToAgentStandardImpl.class);
		}
		
		@Override
	    public void serialize(
	    		LinkToAgentStandardImpl value, JsonGenerator jgen, SerializerProvider provider) 
	      throws IOException, JsonProcessingException {
			jgen.writeStartObject();
			jgen.writeStringField("owner", value.getOwner().getName());
			jgen.writeNumberField("connections_count", value.getConnectionsNumber());
			jgen.writeEndObject();
		}
	}
	
	public static class AbstractMarkupSerializer extends ACustomSerializer<AbstractMarkup> {
		
		public AbstractMarkupSerializer() {
			super(AbstractMarkup.class);
		}
		
		@Override
	    public void serialize(
	    		AbstractMarkup value, JsonGenerator jgen, SerializerProvider provider) 
	      throws IOException, JsonProcessingException {
			if (value instanceof AnimationStaticLocationProvider) { // interface, so won't be detected as a standalone class
				// implemented by AreaNode, ConveyorCustomStation, ConveyorNode, ConveyorPath, ConveyorPointNode, ConveyorPortImpl, ConveyorTransferTable, ConveyorTransitionalNode, ConveyorTurnStation, ConveyorTurntable, 
				//					GISNode, GISPoint, GISRegion, GISRoute, NetworkPortImpl, Node, Path, PointNode, PolygonalNode, QueueArea, RectangularNode
				jgen.writeStartObject();
				
				AnimationStaticLocationProvider providerValue = (AnimationStaticLocationProvider) value;
				Position pos = providerValue.getPosition(0, 5, null); //  TODO only write the parts of the position that correspond to the space the object lives in
				
				jgen.writeObjectField("position", pos); // gets position 0 (which can be for the object itself or its start location)
				jgen.writeObjectField("space_type", providerValue.getSpace().getAgentSpaceType().formatName());
				jgen.writeEndObject();
			} else {
				jgen.writeNull();
			}
			
		}
	}
	
	/**
	 * Parent class of all network types ("normal" networks, gis, conveyor, road, rail, level containers).
	 * Specifically important because these types have `getSpace()` methods that can cause recursive issues.
	 */
	public static class AbstractMarkupAggregatorSerializer extends ACustomSerializer<AbstractMarkupAggregator> {
		
		public AbstractMarkupAggregatorSerializer() {
			super(AbstractMarkupAggregator.class);
		}
		
		@Override
	    public void serialize(
	    		AbstractMarkupAggregator value, JsonGenerator jgen, SerializerProvider provider) 
	      throws IOException, JsonProcessingException {
			jgen.writeNull();
		}
	}
	
	/**
	 * Parent class of Shape3D, ShapeCAD, ShapeCanvas, ShapeControl, ShapeEmbeddedObjectIcon, ShapeInspect, 
	 * 					ShapeModelPrimitives, ShapeScale, ShapeSVG
	 */
	public static class ShapeSerializer extends ACustomSerializer<Shape> {
		
		public ShapeSerializer() {
			super(Shape.class);
		}
		
		
		@Override
	    public void serialize(
	    		Shape value, JsonGenerator jgen, SerializerProvider provider) 
	      throws IOException, JsonProcessingException {
			jgen.writeStartObject();
			
			jgen.writeObjectFieldStart("position");
			jgen.writeNumberField("x", value.getX());
			jgen.writeNumberField("y", value.getY());
			jgen.writeEndObject();
			jgen.writeObjectFieldStart("scale");
			jgen.writeNumberField("x", value.getScaleX());
			jgen.writeNumberField("y", value.getScaleY());
			jgen.writeEndObject();
			
			jgen.writeEndObject();
		}
	}
	
	/**
	 * Parent class of AbstractShapeGISMap, Shape3DObject, ShapeEmbeddedObjectPresentation, ShapeGroup, 
	 * 					ShapeImage, ShapeLine, ShapeLineFill, ShapeText
	 */
	public static class Shape3DSerializer extends ACustomSerializer<Shape3D> {
		
		public Shape3DSerializer() {
			super(Shape3D.class);
		}
		
		
		@Override
	    public void serialize(
	    		Shape3D value, JsonGenerator jgen, SerializerProvider provider) 
	      throws IOException, JsonProcessingException {
			jgen.writeStartObject();
			
			jgen.writeObjectFieldStart("position");
			jgen.writeNumberField("x", value.getX());
			jgen.writeNumberField("y", value.getY());
			jgen.writeNumberField("z", value.getZ());
			jgen.writeNumberField("rotation", value.getRotation());
			jgen.writeEndObject();
			jgen.writeObjectFieldStart("scale");
			jgen.writeNumberField("x", value.getScaleX());
			jgen.writeNumberField("y", value.getScaleY());
			jgen.writeNumberField("z", value.getScaleZ());
			jgen.writeEndObject();
			
			jgen.writeEndObject();
		}
	}
	
	/**
	 * Parent class of database tables
	 */
	public static class TableSerializer extends ACustomSerializer<RelationalPathBase> {
		
		public TableSerializer() {
			super(RelationalPathBase.class);
		}
		
		
		@Override
	    public void serialize(
	    		RelationalPathBase value, JsonGenerator jgen, SerializerProvider provider) 
	      throws IOException, JsonProcessingException {
			
			// Get column names/types and constraints for the specified table
	        String tableName = value.getTableName();
			List<Map<String, Object>> columns = new ArrayList<>();
	        List<Map<String, Object>> primaryKeys = new ArrayList<>();
	        List<Map<String, Object>> foreignKeys = new ArrayList<>();

	        // get column info
	        for (Object colObj : value.getColumns()) {
	        	Path<?> col = (Path<?>)colObj;
	        	columns.add(
	        		new LinkedHashMap<>(
	        			Map.of("column_name", col.getMetadata().getName(), 
	        					"column_type", col.getType().getName())
	        		)
	        	);
	        }

	        // get primary key info
	        PrimaryKey<?> primaryKey = value.getPrimaryKey();
	        if (primaryKey != null) {
	            for (Expression<?> expression : primaryKey.getLocalColumns()) {
	                primaryKeys.add(
	                	new LinkedHashMap<>(
	                		Map.of("column_name", ((Path<?>) expression).getMetadata().getName())
	                	)
	                );
	            }
	        }
	        
	        // get foreign key info
	        for (Object foreignKeyObj : value.getForeignKeys()) {
	        	ForeignKey<?> foreignKey = (ForeignKey<?>) foreignKeyObj;
	            Map<String, Object> foreignKeyInfo = new HashMap<>();
	            List<String> foreignKeyColumns = new ArrayList<>();
	            List<String> referencedColumns = new ArrayList<>();

	            for (Expression<?> localColumn : foreignKey.getLocalColumns()) {
	                foreignKeyColumns.add(((Path<?>) localColumn).getMetadata().getName());
	            }

	            for (String referencedColumn : foreignKey.getForeignColumns()) {
	                referencedColumns.add(referencedColumn);
	            }

	            foreignKeyInfo.put("column_names", foreignKeyColumns);
	            foreignKeyInfo.put("referenced_column_names", referencedColumns);
	            //foreignKeyInfo.put("referenced_table_name", foreignKey.getForeignTable().getTableName());
	            foreignKeys.add(foreignKeyInfo);
	        }
	        
			
	        jgen.writeStartObject();
	        jgen.writeStringField("table_name", tableName);
	        jgen.writeObjectField("columns", columns);
	        jgen.writeObjectField("constraints", new LinkedHashMap<String, Object>(Map.of("primary_keys", primaryKeys, "foreign_keys", foreignKeys)));
	        
	        // cannot get data without reference to the database
	        if (PyCommunicator.root != null) {
	        	List<List<Object>> data = new ArrayList<>();
	        	try {
				    java.sql.Statement statement = PyCommunicator.root.getDatabaseConnection().createStatement();
				    String columnCSV = columns.stream().map(c -> (String)c.get("column_name")).collect(Collectors.joining(",")); 
				    java.sql.ResultSet resultSet = statement.executeQuery("SELECT " + columnCSV + " FROM " + tableName);
				    java.sql.ResultSetMetaData resultSetMetaData = resultSet.getMetaData();
				    int columnCount = resultSetMetaData.getColumnCount();
				    while (resultSet.next()) {
				        List<Object> row = new ArrayList<>();
				        for (int i = 1; i <= columnCount; i++) {
				            row.add(resultSet.getObject(i));
				        }
				        data.add(row);
				    }
				    jgen.writeObjectField("data", data);
	        	} catch (SQLException e) {
	        		e.printStackTrace();
	        	}
	        }
	        
			jgen.writeEndObject();
		}
	}
	
	public static class DatabaseConnectionSerializer extends ACustomSerializer<Connection> {
		
		public DatabaseConnectionSerializer() {
			super(Connection.class);
		}
		
		@Override
	    public void serialize(Connection value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonProcessingException {
			try {
				jgen.writeStartArray();
				
				java.sql.DatabaseMetaData metadata = value.getMetaData();
				java.sql.ResultSet tables = metadata.getTables(null, null, null, new String[] {"TABLE"});
				
				while (tables.next()) {
					// lookup this table's name
					String tableName = tables.getString("TABLE_NAME");
					
					// build columns info
					List<Map<String, Object>> columns = new ArrayList<>();
				    java.sql.ResultSet columnsResultSet = metadata.getColumns(null, null, tableName, null);
				    while (columnsResultSet.next()) {
				        Map<String, Object> columnInfo = new LinkedHashMap<>();
				        columnInfo.put("column_name", columnsResultSet.getString("COLUMN_NAME"));
				        columnInfo.put("column_type", columnsResultSet.getString("TYPE_NAME"));
				        columns.add(columnInfo);
				    }
				    
				    // build constraints info
				    Map<String, List<Map<String, Object>>> constraints = Map.of("primary_keys", new ArrayList<>(), "foreign_keys", new ArrayList<>());
				    java.sql.ResultSet primaryKeysResultSet = metadata.getPrimaryKeys(null, null, tableName);
				    while (primaryKeysResultSet.next()) {
				        Map<String, Object> primaryKeyInfo = new LinkedHashMap<>();
				        primaryKeyInfo.put("column_name", primaryKeysResultSet.getString("COLUMN_NAME"));
				        constraints.get("primary_keys").add(primaryKeyInfo);
				    }
				    java.sql.ResultSet foreignKeysResultSet = metadata.getImportedKeys(null, null, tableName);
				    while (foreignKeysResultSet.next()) {
				        Map<String, Object> foreignKeyInfo = new LinkedHashMap<>();
				        foreignKeyInfo.put("column_name", foreignKeysResultSet.getString("FKCOLUMN_NAME"));
				        foreignKeyInfo.put("referenced_table_name", foreignKeysResultSet.getString("PKTABLE_NAME"));
				        foreignKeyInfo.put("referenced_column_name", foreignKeysResultSet.getString("PKCOLUMN_NAME"));
				        constraints.get("foreign_keys").add(foreignKeyInfo);
				    }
				    
				    // build data info
				    List<List<Object>> data = new ArrayList<>();
				    java.sql.Statement statement = value.createStatement();
				    String columnCSV = columns.stream().map(c -> (String)c.get("column_name")).collect(Collectors.joining(","));    
				    java.sql.ResultSet resultSet = statement.executeQuery("SELECT " + columnCSV + " FROM " + tableName);
				    java.sql.ResultSetMetaData resultSetMetaData = resultSet.getMetaData();
				    int columnCount = resultSetMetaData.getColumnCount();
				    while (resultSet.next()) {
				        List<Object> row = new ArrayList<>();
				        for (int i = 1; i <= columnCount; i++) {
				            row.add(resultSet.getObject(i));
				        }
				        data.add(row);
				    }
				    
				    // now add a new entry to the JSON
				    jgen.writeStartObject();
				    jgen.writeStringField("table_name", tableName);
				    jgen.writeObjectField("columns", columns);
				    jgen.writeObjectField("constraints", constraints);
				    jgen.writeObjectField("data", data);
				    jgen.writeEndObject();
				}
				
			    jgen.writeEndArray();
			    
			} catch (SQLException e) {
				jgen.writeNull();
			}
		}
	}
	
	public static class TupleSerializer extends ACustomSerializer<Tuple> {
		
		public TupleSerializer() {
			super(Tuple.class);
		}
		
		@Override
	    public void serialize(Tuple value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonProcessingException {
	        jgen.writeStartArray();
	        for (Object obj : value.toArray()) {
	            jgen.writeObject(obj);
	        }
	        jgen.writeEndArray();
		}
	}
}]]></Text>
		</JavaClass>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1678490259125</Id>
			<Name><![CDATA[SharedSuppressionMixIn]]></Name>
			<Text><![CDATA[import com.fasterxml.jackson.annotation.JsonIgnore;

public interface SharedSuppressionMixIn
{
	
	@JsonIgnore
    public Agent getActiveObject();
	
	@JsonIgnore
	public Agent getAgent();
	
	
	
}]]></Text>
		</JavaClass>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1678494803375</Id>
			<Name><![CDATA[PortSuppressionMixIn]]></Name>
			<Text><![CDATA[import com.fasterxml.jackson.annotation.JsonIgnore;

public interface PortSuppressionMixIn extends SharedSuppressionMixIn
{
	@JsonIgnore
	public String getName();
	
	@JsonIgnore
	public String getFullName();
	
	@JsonIgnore
	public FlowchartBlock getFlowchartBlockRepresentative();
	
	@JsonIgnore
	public FlowchartBlock getFlowchartBlockRepresentative(Agent agent);
	
	@JsonIgnore
	public List getStatechartLinks();
	
	@JsonIgnore
	public List getFlatLinks();
	
	@JsonIgnore
	public List getUpLinks();
	
	@JsonIgnore
	public List getDownLinks();
}]]></Text>
		</JavaClass>
		<!--   =========   Java Class   ========  -->
		<JavaClass>
			<Id>1684173946558</Id>
			<Name><![CDATA[Deserializers]]></Name>
			<Text><![CDATA[import java.io.IOException;
import com.fasterxml.jackson.databind.deser.std.StdDeserializer;
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.DeserializationContext;
import com.fasterxml.jackson.databind.JsonDeserializer;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;

/**
 * Container class for all deserializers.
 * Technical notes: - Contains one base class (ACustomDeserializer) intended to have the proper constructors and initial methods.
 * 					- All other classes extend this for each class it wants to deserialize for; 
 * 						they need to implement the empty constructor calling `super(Classname.class)` and the abstract function.
 * 					- Use this class's `register` function to add the classes to the provided ObjectMapper
 * 					- Note: Jackson will use whatever class matches the lowest level class, 
 * 						enabling simple parent class serializers and more useful/specific child class serializers.
 */
public class Deserializers {
	
	public static void register(ObjectMapper mapper, Class<?>... desClasses) {
		SimpleModule module = new SimpleModule();
		for (Class<?> c : desClasses) {
			try {
				ACustomDeserializer d = (ACustomDeserializer)c.getDeclaredConstructor().newInstance();
				module.addDeserializer(d.handledType(), d);
			} catch (Exception e) {
				e.printStackTrace();
			}
		}
		mapper.registerModule(module);
	}

	public abstract static class ACustomDeserializer<T> extends StdDeserializer<T> {
		public ACustomDeserializer() {
			this(null);
		}
		
		public ACustomDeserializer(Class<T> t) {
			super(t);
		}
		
		public abstract T deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException;
	}
	
	public static class PointDeserializer extends ACustomDeserializer<Point> {
		
		public PointDeserializer() {
			super(Point.class);
		}

		@Override
		public Point deserialize(JsonParser jp, DeserializationContext ctxt)  
				throws IOException, JsonProcessingException {
			JsonNode node = jp.getCodec().readTree(jp);
			double x, y, z;
			if (node.isArray()) {
		        // Handle JSON array, intended to be size 2 or 3
				if (node.size() < 2)
					throw new IOException("Array must be at least 2-length.");
		        x = node.get(0).asDouble();
		        y = node.get(1).asDouble();
		        z = node.size() > 2 ? node.get(2).asDouble() : 0;
		        
		    } else {
		    	// Handle JSON object, intended to have at least 'x' and 'y' keys (or 'lat' and 'lon') and possibly 'z'
		    	if (node.has("x") && node.has("y")) {
		    		x = node.get("x").asDouble();
		    		y = node.get("y").asDouble();
		    		z = node.has("z") ? node.get("z").asDouble() : 0;
		    	} else if (node.has("lat") && node.has("lon")) {
		    		x = node.get("lat").asDouble();
		    		y = node.get("lon").asDouble();
		    		z = 0d;
		    	} else {
		    		throw new IOException("Object must have at least keys 'x' and 'y' or 'lat' and 'lon'");
		    	}
		    }
			return new Point(x, y, z);
		}
	}
	
	public static class PositionDeserializer extends ACustomDeserializer<Position> {
		
		public PositionDeserializer() {
			super(Position.class);
		}

		@Override
		public Position deserialize(JsonParser jp, DeserializationContext ctxt)  
				throws IOException, JsonProcessingException {
			JsonNode node = jp.getCodec().readTree(jp);
			double x, y, z, r, vr;
			if (node.isArray()) {
		        // Handle JSON array, intended to be size 2 - 5
				// 2 = x, y
				// 3 = x, y, r
				// 4 = x, y, z, r
				// 5 = x, y, z, r, vr
				final int size = node.size();
				if (size < 2 || size > 5)
					throw new IOException("Array must be a length between 2 and 5.");
				x = node.get(0).asDouble();
				y = node.get(1).asDouble();
				if (size == 3) {
					z = 0d;
					r = node.get(2).asDouble();
					vr = 0d;
				} else {
					z = node.get(2).asDouble();
					r = node.get(3).asDouble();
					vr = size == 5 ? node.get(4).asDouble() : 0d;
				}
		    } else {
		        // Handle JSON object, expecting at least 'x' and 'y' keys (or 'lat' and 'lon'), possibly 'z', 'rotation', and ('vertical_rotation' OR 'verticalRotation')
		    	if (!node.has("x") || !node.has("y"))
		    		throw new IOException("Object must have at least keys 'x' and 'y'");
		    	if (node.has("x") && node.has("y")) {
		    		x = node.get("x").asDouble();
		    		y = node.get("y").asDouble();
		    	} else if (node.has("lat") && node.has("lon")) {
		    		x = node.get("lat").asDouble();
		    		y = node.get("lon").asDouble();
		    	} else {
		    		throw new IOException("Object must have at least keys 'x' and 'y' or 'lat' and 'lon'");
		    	}
    			z = node.has("z") ? node.get("z").asDouble() : 0d;
    			r = node.has("rotation") ? node.get("rotation").asDouble() : 0d;
    			vr = node.has("vertical_rotation") 
    				? node.get("vertical_rotation").asDouble() 
    				: node.has("verticalRotation") 
    					? node.get("verticalRotation").asDouble() 
    					: 0d;
		    }
			return new Position(x, y, z, r, vr);
		}
	}
	
	
}]]></Text>
		</JavaClass>
	</JavaClasses>
	<Libraries>
		<!--   =========   Library   ========  -->
		<Library>
			<Id>1567903824199</Id>
			<Name><![CDATA[Pypeline]]></Name>
			<Description><![CDATA[The library that allows you to run Python code within AnyLogic model.]]></Description>
			<AOCEntry>
				<ActiveObjectClassId>1569858524855</ActiveObjectClassId>
				<Icon16ResourceReference>
					<PackageName><![CDATA[com.anylogic.libraries.pypeline]]></PackageName>
					<ClassName><![CDATA[Python-logo-16.png]]></ClassName>
				</Icon16ResourceReference>
				<Icon32ResourceReference>
					<PackageName><![CDATA[com.anylogic.libraries.pypeline]]></PackageName>
					<ClassName><![CDATA[Python-logo-32.png]]></ClassName>
				</Icon32ResourceReference>
			</AOCEntry>
			<AOCEntry>
				<ActiveObjectClassId>1665787765899</ActiveObjectClassId>
				<Icon16ResourceReference>
					<PackageName><![CDATA[com.anylogic.libraries.pypeline]]></PackageName>
					<ClassName><![CDATA[jsonifier_16.png]]></ClassName>
				</Icon16ResourceReference>
				<Icon32ResourceReference>
					<PackageName><![CDATA[com.anylogic.libraries.pypeline]]></PackageName>
					<ClassName><![CDATA[jsonifier_32.png]]></ClassName>
				</Icon32ResourceReference>
			</AOCEntry>

			<IconResourceReference>
				<PackageName><![CDATA[com.anylogic.libraries.pypeline]]></PackageName>
				<ClassName><![CDATA[Pypeline-libicon.png]]></ClassName>
			</IconResourceReference>
			<VersionMajor>1</VersionMajor>
			<VersionMinor>9</VersionMinor>
			<VersionBuild>3</VersionBuild>
			<Provider><![CDATA[Tyler Wolfe-Adam]]></Provider>    
		</Library>
	</Libraries>
	<ModelResources>
		<Resource>
			<Path><![CDATA[Python-logo-16.png]]></Path>
			<ReferencedFromUserCode>false</ReferencedFromUserCode>
		</Resource>
		<Resource>
			<Path><![CDATA[Python-logo-32.png]]></Path>
			<ReferencedFromUserCode>false</ReferencedFromUserCode>
		</Resource>
		<Resource>
			<Path><![CDATA[Python-logo.png]]></Path>
			<ReferencedFromUserCode>false</ReferencedFromUserCode>
		</Resource>
		<Resource>
			<Path><![CDATA[Pypeline-libicon.png]]></Path>
			<ReferencedFromUserCode>false</ReferencedFromUserCode>
		</Resource>
		<Resource>
			<Path><![CDATA[jsonifier_16.png]]></Path>
			<ReferencedFromUserCode>false</ReferencedFromUserCode>
		</Resource>
		<Resource>
			<Path><![CDATA[jsonifier_32.png]]></Path>
			<ReferencedFromUserCode>false</ReferencedFromUserCode>
		</Resource>
	</ModelResources>
    <RequiredLibraryReference>
		<LibraryName><![CDATA[com.anylogic.libraries.modules.markup_descriptors]]></LibraryName>
		<VersionMajor>1</VersionMajor>
		<VersionMinor>0</VersionMinor>
		<VersionBuild>0</VersionBuild>
    </RequiredLibraryReference>
</Model>
</AnyLogicWorkspace>